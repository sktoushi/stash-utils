<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IndexedDB CSV + Flashcards</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome for Icons -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    body {
      background-color: #f8f9fa;
    }
    .container {
      /* Widen the max width for the cards */
      max-width: 1200px;
      margin-top: 30px;
      margin-bottom: 100px;
    }
    /* Larger button sizing for thumb presses */
    .btn {
      padding-top: 1rem;
      padding-bottom: 1rem;
      font-size: 1rem;
    }
    .btn-draw, .btn-reveal {
      width: 100%;
      margin-bottom: 20px;
    }
    .slider-container {
      margin-bottom: 20px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
    }
    .btn-export {
      margin-top: 10px;
    }
    .gauge-container {
      margin-bottom: 20px;
    }
    .bucket-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .flashcard {
      border: 2px dashed #aaa;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      margin-bottom: 20px;
      background-color: #ffffff;
      /* Make it wider with some min-width or overall responsiveness */
      width: 100%;
    }
    .reveal-section {
      display: none; /* Hidden until "Reveal Answer" is clicked */
    }
    #frontTextContainer {
      margin-bottom: 40px;
    }
    .toast-container {
      z-index: 9999;
    }
    .info-box {
      background-color: #e9ecef;
      border-radius: 5px;
      padding: 10px;
      margin-top: 10px;
    }
    /* Progress bar container for CSV/Text uploads */
    .upload-progress-container {
      display: none; /* hidden by default */
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <!-- Display random Pantone color in top-right corner (optional) -->
  <div id="pantoneColorDisplay"
       style="position: absolute; top: 10px; right: 10px; background-color: #ffffffcc; padding: 5px; border-radius: 5px; font-weight: bold;"></div>

  <div class="container">
    <h1 class="text-center" id="pageTitle">IndexedDB CSV + Flashcards</h1>

    <!-- Help (no dark mode button now) -->
    <div class="text-end mb-3">
      <button class="btn btn-info btn-lg" data-bs-toggle="modal" data-bs-target="#helpModal" title="Help">
        <i class="fas fa-question-circle"></i> Help
      </button>
    </div>

    <!-- Upload + Text Input Row -->
    <div class="row mb-4">
      <div class="col-md-6 mb-3">
        <label class="form-label">Upload CSV(s):</label>
        <input type="file" id="csvFileInput" multiple accept=".csv" class="form-control" />
        <div class="form-text">Each CSV line is assumed "front,back". Duplicates are removed. Newly inserted records go into Bucket2 automatically.</div>
        <button class="btn btn-primary btn-lg mt-2" onclick="handleFiles()">Import to IndexedDB</button>

        <!-- Progress bar for CSV uploading -->
        <div id="csvUploadProgressContainer" class="upload-progress-container">
          <div class="progress">
            <div id="csvUploadProgressBar" class="progress-bar" role="progressbar" style="width: 0%">0%</div>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <label class="form-label">Add Text Post:</label>
        <textarea id="textPostInput" class="form-control" rows="3" placeholder="Type your text, like a GitHub Issue..."></textarea>
        <div class="form-text">We'll replace all commas with underscores and store as: "YYMMDD hh:mm:ss, text" (then added to Bucket2).</div>
        <button class="btn btn-success btn-lg mt-2" onclick="addTextPost()">Add Text to DB</button>

        <!-- Progress bar for text upload -->
        <div id="textUploadProgressContainer" class="upload-progress-container">
          <div class="progress">
            <div id="textUploadProgressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%">0%</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Download + DB Size Info -->
    <div class="row mb-4">
      <div class="col-md-6 mb-3">
        <button class="btn btn-dark btn-lg" onclick="downloadAllRecords()">Download All as CSV</button>
        <button class="btn btn-danger btn-lg ms-2" onclick="clearDatabase()">Clear IndexedDB</button>
        <div class="info-box mt-2">
          <strong>DB Size:</strong>
          <span id="dbSizeSpan">0 kB</span>
        </div>
      </div>
      <div class="col-md-6">
        <!-- Just a placeholder area if needed -->
      </div>
    </div>

    <hr/>

    <!-- Probability Slider for Flashcard Buckets -->
    <div class="slider-container">
      <label for="probSlider" class="form-label">Adjust Probabilities (Bucket1 vs Bucket2):</label>
      <input type="range" class="form-range" id="probSlider" min="0" max="100" value="33"
             oninput="updateProbabilities()" title="Probability of drawing from Bucket 1">
      <div class="slider-label">
        <span>Bucket 1: <span id="probBucket1">33%</span></span>
        <span>Bucket 2: <span id="probBucket2">67%</span></span>
      </div>
    </div>

    <!-- Draw, Reveal, Undo Buttons -->
    <button class="btn btn-primary btn-lg btn-draw" onclick="drawCard()" title="Draw a card to review">
      <i class="fas fa-random"></i> Draw Card
    </button>
    <button class="btn btn-secondary btn-lg btn-reveal" onclick="revealAnswer()" title="Reveal the back of the card">
      <i class="fas fa-eye"></i> Reveal Answer
    </button>
    <button class="btn btn-warning btn-lg btn-draw" onclick="undoLastDraw()" title="Undo the last drawn card">
      <i class="fas fa-undo"></i> Undo Last Draw
    </button>

    <!-- Flashcard Display -->
    <div class="flashcard" id="flashcard">
      <!-- FRONT TEXT container -->
      <div id="frontTextContainer">
        <span id="frontText"></span>
      </div>
      <!-- BACK TEXT container (hidden by default until reveal) -->
      <div id="backTextContainer" class="reveal-section">
        <span id="backText"></span>
      </div>
    </div>

    <!-- Action Buttons for the Flashcard (Copy & Open as Link) -->
    <div id="additionalFlashcardButtons" style="text-align:center; margin-bottom:20px;">
      <button class="btn btn-success btn-lg" onclick="copyFrontText()">Copy Front</button>
      <button class="btn btn-success btn-lg" onclick="copyBackText()">Copy Back</button>
      <button class="btn btn-info btn-lg" onclick="openFrontAsLink()">Open Front as Link</button>
      <button class="btn btn-info btn-lg" onclick="openBackAsLink()">Open Back as Link</button>
    </div>

    <!-- Search Buttons (Google & ChatGPT); hidden until reveal -->
    <div id="googleSearchButtons" style="display: none; text-align:center; margin-bottom:20px;">
      <button class="btn btn-outline-primary btn-lg" onclick="googleSearchFront()">Search Google (Front)</button>
      <button class="btn btn-outline-primary btn-lg" onclick="googleSearchBack()">Search Google (Back)</button>
      <button class="btn btn-outline-success btn-lg" onclick="chatGPTSearchFront()">Search ChatGPT (Front)</button>
      <button class="btn btn-outline-success btn-lg" onclick="chatGPTSearchBack()">Search ChatGPT (Back)</button>
      <button class="btn btn-outline-info btn-lg" onclick="jishoSearchFront()">Search Jisho (Front)</button>
      <button class="btn btn-outline-info btn-lg" onclick="jishoSearchBack()">Search Jisho (Back)</button>
    </div>

    <!-- Review Gauges -->
    <div class="gauge-container">
      <label for="review1Gauge" class="form-label">Review1 (Unique Bucket1 Items / Total Cards):</label>
      <progress id="review1Gauge" class="form-range w-100" value="0" max="100" aria-label="Review1 Gauge"></progress>
      <div class="text-center">
        <span id="review1Text">0%</span>
      </div>
    </div>

    <div class="gauge-container">
      <label for="review2Gauge" class="form-label">Remaining (100% - Review1):</label>
      <progress id="review2Gauge" class="form-range w-100" value="100" max="100" aria-label="Review2 Gauge"></progress>
      <div class="text-center">
        <span id="review2Text">100%</span>
      </div>
    </div>

    <!-- Bucket Lists -->
    <div class="row">
      <div class="col-md-6">
        <h5>Bucket 1 Total Frequency: <span id="bucket1Freq">0</span></h5>
        <ul class="list-group bucket-list" id="bucket1List" aria-label="Bucket 1 Items"></ul>
      </div>
      <div class="col-md-6">
        <h5>Bucket 2 Total Frequency: <span id="bucket2Freq">0</span></h5>
        <ul class="list-group bucket-list" id="bucket2List" aria-label="Bucket 2 Items"></ul>
      </div>
    </div>

    <!-- Draw History -->
    <div class="mt-4">
      <h5>Draw History (Last 5):</h5>
      <ul class="list-group history-list" id="historyList" aria-label="Draw History"></ul>
    </div>

    <!-- Action Buttons (Export/Import/Reset) -->
    <div class="text-center mt-4">
      <button class="btn btn-secondary btn-lg btn-export" onclick="exportState()" title="Export current review state as JSON">
        <i class="fas fa-file-export"></i> Export Buckets
      </button>
      <button class="btn btn-secondary btn-lg btn-export" onclick="importState()" title="Import an existing state from a JSON file">
        <i class="fas fa-file-import"></i> Import Buckets
      </button>
      <button class="btn btn-danger btn-lg btn-export" onclick="resetBuckets()" title="Reset just the Bucket1/Bucket2 arrangement">
        <i class="fas fa-trash-alt"></i> Reset Buckets
      </button>
    </div>

    <!-- Toast Container -->
    <div aria-live="polite" aria-atomic="true" class="position-relative toast-container">
      <div id="toastContainer" class="position-fixed bottom-0 end-0 p-3" style="z-index: 11;">
        <!-- Toasts appended here -->
      </div>
    </div>

    <!-- Help Modal -->
    <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="helpModalLabel">Help & Instructions</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <h6>Overview</h6>
            <p>
              This page lets you upload CSV files or add text as CSV-like rows, storing them in IndexedDB.
              Each record gets a unique integer <code>id</code>. We automatically place new records into “Bucket2” for flashcard reviewing.
            </p>
            <p>
              When building flashcards, each record (e.g. "front,back") is turned into <em>two</em> flashcards:
              front→back and back→front. Their internal IDs are <code>2*id</code> and <code>2*id + 1</code> 
              (so the same DB record yields two directions).
            </p>
            <h6>Usage Steps</h6>
            <ol>
              <li><strong>Upload CSV(s)</strong> or <strong>Add Text Post</strong>. 
                  After progress completes, the file input/textbox is cleared. 
                  All new lines go into Bucket2, so they can be drawn as flashcards.</li>
              <li><strong>Download All as CSV</strong>: merges everything in the DB into a single CSV, removing duplicates. 
                  Filename is <code>indexedDb-YYMMDD_hhmm-minID-maxID.csv</code>.</li>
              <li><strong>Clear IndexedDB</strong>: <em>removes</em> all records permanently. 
                  Be careful if you want to keep your data!</li>
              <li>The <strong>Flashcard</strong> area uses two buckets (reviewed vs. not-reviewed). 
                  Use <strong>Draw Card</strong>, <strong>Reveal</strong>, <strong>Undo</strong>, etc.</li>
              <li>You can <strong>Copy</strong> or <strong>Open as Link</strong> the front/back content. 
                  Also, the <strong>Search Google/ChatGPT/Jisho</strong> buttons appear once you reveal the card.</li>
              <li><strong>Reset Buckets</strong>: clears your flashcard progress (but not the underlying DB!). 
                  Useful if you want to start reviewing from scratch.</li>
            </ol>
            <h6>Notes</h6>
            <ul>
              <li>DB size is displayed in kB (approximate, based on sum of text lengths / 1024).</li>
              <li>If your CSV line is single-column or if you <em>only</em> have "front" text, 
                  the “back” will be empty for that row. This still yields two directions: <code>front → ""</code> and <code>"" → front</code>.</li>
              <li>The random Pantone background colors come from an optional <code>pantone-colors.json</code> file. 
                  If missing, background defaults to white.</li>
            </ul>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary btn-lg" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

  </div> <!-- /container -->

  <!-- Bootstrap JS and dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-wpsYrgENSMwvWDnK+0hqyc+8zhu+uZdzsOCS8KQmS1b2y2lZjY0Chvh6e+GD44G"
          crossorigin="anonymous"></script>

  <script>
    /****************************************************
     *         INDEXEDDB + CSV/TEXT UPLOAD LOGIC
     ****************************************************/
    const DB_NAME = 'myCsvDb';
    const DB_VERSION = 1;
    const STORE_NAME = 'records';
    let db = null;

    // In-memory array of all DB records -> {id, text}
    let allRecords = [];

    // Flashcard bucket state
    let state = {
      b1: {}, // { virtualId: frequency }
      b2: {}, // { virtualId: frequency }
      uniqueBucket1Count: 0,
      b1Prob: 0.33,
      b2Prob: 0.67,
      drawHistory: []
    };
    const historyLimit = 5;
    let lastDrawnId = null;
    let localBucketsKey = "flashcardBuckets_v1";

    window.addEventListener('load', async () => {
      await openDatabase();
      await loadAllRecordsToMemory();
      updateDbSizeDisplay();
      loadBucketState(); // load existing bucket arrangement
      updateProbabilities();
      populateBucketLists();
      populateHistoryList();
      updateDisplay();
      getRandomColor();

      // Make all buttons also trigger a new random color, for fun
      const allButtons = document.querySelectorAll('button');
      allButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          getRandomColor();
        });
      });
    });

    async function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, {
              keyPath: 'id',
              autoIncrement: true
            });
            store.createIndex('textIndex', 'text', { unique: true });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };
        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    async function loadAllRecordsToMemory() {
      allRecords = [];
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.openCursor();
        request.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            allRecords.push({ id: cursor.value.id, text: cursor.value.text });
            cursor.continue();
          } else {
            resolve();
          }
        };
        request.onerror = (err) => reject(err);
      });
    }

    function updateDbSizeDisplay() {
      // Sum text lengths, approximate in kB
      let totalChars = 0;
      for (const rec of allRecords) {
        totalChars += rec.text.length;
      }
      const kB = (totalChars / 1024).toFixed(2);
      document.getElementById("dbSizeSpan").textContent = `${kB} kB`;
    }

    // CSV upload
    async function handleFiles() {
      const fileInput = document.getElementById('csvFileInput');
      const files = fileInput.files;
      if (!files || files.length === 0) {
        alert("No CSV file selected.");
        return;
      }
      showCsvUploadProgress(true);
      let totalInserted = 0;
      let totalLines = 0;

      for (const file of files) {
        const text = await file.text();
        const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        totalLines += lines.length;
        // Insert lines
        const inserted = await addLinesToDb(lines, /*useProgressBar=*/true, lines.length);
        totalInserted += inserted;
      }

      // Clear the file input after success
      fileInput.value = "";
      showCsvUploadProgress(false);

      showToast(`Imported ${totalInserted} new line(s) out of ${totalLines} total lines read.`);
      await refreshData();
    }

    // Common function to add lines to DB, removing duplicates
    async function addLinesToDb(lines, useProgressBar=false, totalCount=0) {
      // We'll insert them in a single transaction. We also track progress if needed.
      return new Promise((resolve, reject) => {
        let addedCount = 0;
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const textIndex = store.index('textIndex');

        let processedCount = 0;

        function processNextLine(i) {
          if (i >= lines.length) {
            resolve(addedCount);
            return;
          }
          const line = lines[i];
          if (!line.trim()) {
            processedCount++;
            if (useProgressBar) updateCsvUploadProgress(processedCount, totalCount);
            processNextLine(i + 1);
            return;
          }
          // Check for duplicate
          const checkReq = textIndex.get(line);
          checkReq.onsuccess = () => {
            if (checkReq.result) {
              // Already exists, skip
              processedCount++;
              if (useProgressBar) updateCsvUploadProgress(processedCount, totalCount);
              processNextLine(i + 1);
            } else {
              const addReq = store.add({ text: line });
              addReq.onsuccess = (evt) => {
                addedCount++;
                processedCount++;
                if (useProgressBar) updateCsvUploadProgress(processedCount, totalCount);

                // The newly inserted record ID
                const newId = evt.target.result;
                // Put them in bucket2 automatically (both directions)
                addRecordToBucket2(newId);

                processNextLine(i + 1);
              };
              addReq.onerror = (err) => {
                console.error(err);
                processedCount++;
                if (useProgressBar) updateCsvUploadProgress(processedCount, totalCount);
                processNextLine(i + 1);
              };
            }
          };
          checkReq.onerror = (err) => {
            console.error(err);
            processedCount++;
            if (useProgressBar) updateCsvUploadProgress(processedCount, totalCount);
            processNextLine(i + 1);
          };
        }

        tx.oncomplete = () => {
          // Save bucket changes
          saveBucketState();
        };
        tx.onerror = (err) => {
          console.error('Transaction error:', err);
          reject(err);
        };

        processNextLine(0);
      });
    }

    async function refreshData() {
      await loadAllRecordsToMemory();
      updateDbSizeDisplay();
    }

    function addRecordToBucket2(dbId) {
      // We'll store "2*dbId" and "2*dbId+1" with freq=1 in Bucket2 if not exist
      const frontId = 2 * dbId;
      const backId = 2 * dbId + 1;
      if (!state.b1[frontId] && !state.b2[frontId]) {
        state.b2[frontId] = 1;
      }
      if (!state.b1[backId] && !state.b2[backId]) {
        state.b2[backId] = 1;
      }
    }

    // Show/hide & update progress bar for CSV
    function showCsvUploadProgress(show) {
      const container = document.getElementById("csvUploadProgressContainer");
      if (show) {
        container.style.display = "block";
        updateCsvUploadProgress(0, 1); // Reset
      } else {
        container.style.display = "none";
      }
    }
    function updateCsvUploadProgress(current, total) {
      const bar = document.getElementById("csvUploadProgressBar");
      if (total === 0) {
        bar.style.width = "0%";
        bar.textContent = "0%";
        return;
      }
      const pct = Math.floor((current / total) * 100);
      bar.style.width = pct + "%";
      bar.textContent = pct + "%";
    }

    // Text Post
    async function addTextPost() {
      const textArea = document.getElementById('textPostInput');
      let rawText = textArea.value.trim();
      if (!rawText) {
        alert("No text entered.");
        return;
      }

      // Show text progress
      showTextUploadProgress(true);
      updateTextUploadProgress(0, 1);

      // Replace commas with underscores
      rawText = rawText.replace(/,/g, "_");
      // "YYMMDD hh:mm:ss, text"
      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const min = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;
      const fullLine = `${datePrefix}, ${rawText}`;

      const inserted = await addLinesToDb([fullLine], false, 1);
      if (inserted > 0) {
        showToast("Text post added to DB!");
      } else {
        showToast("That exact line already exists in DB; skipping.");
      }
      await refreshData();

      // Clear the text field
      textArea.value = "";

      // Hide text progress
      updateTextUploadProgress(1,1);
      setTimeout(() => showTextUploadProgress(false), 500);
    }

    function showTextUploadProgress(show) {
      const container = document.getElementById("textUploadProgressContainer");
      if (show) {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }
    function updateTextUploadProgress(current, total) {
      const bar = document.getElementById("textUploadProgressBar");
      if (total === 0) {
        bar.style.width = "0%";
        bar.textContent = "0%";
        return;
      }
      const pct = Math.floor((current / total) * 100);
      bar.style.width = pct + "%";
      bar.textContent = pct + "%";
    }

    // Download all DB records as CSV
    async function downloadAllRecords() {
      if (allRecords.length === 0) {
        alert("No records in DB to download.");
        return;
      }
      // Sort by ID ascending
      const sorted = [...allRecords].sort((a, b) => a.id - b.id);
      const minId = sorted[0].id;
      const maxId = sorted[sorted.length - 1].id;

      let csvOutput = "";
      for (const rec of sorted) {
        csvOutput += rec.text + "\n";
      }

      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mo = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const mi = String(now.getMinutes()).padStart(2, '0');

      const fileName = `indexedDb-${yy}${mo}${dd}_${hh}${mi}-${minId}-${maxId}.csv`;
      const blob = new Blob([csvOutput], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
    }

    // Clear entire DB
    async function clearDatabase() {
      if (!confirm("Are you sure you want to clear ALL data in IndexedDB? This is irreversible.")) {
        return;
      }
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const clearReq = store.clear();
      clearReq.onsuccess = async () => {
        showToast("Database cleared!");
        await refreshData();
        // Also clear buckets, because those references won't be valid anymore
        resetBuckets(true); // pass "fully" = true if we want a total reset
      };
      clearReq.onerror = (err) => {
        console.error(err);
      };
    }

    /****************************************************
     *                FLASHCARD LOGIC
     *   We assign two "virtual IDs" for each DB record:
     *    - front->back = 2 * recordId
     *    - back->front = (2 * recordId) + 1
     ****************************************************/
    function buildAllCards() {
      const cards = [];
      for (const r of allRecords) {
        const parts = r.text.split(",");
        const front = (parts[0] || "").trim();
        const back = (parts[1] || "").trim();
        const frontId = 2 * r.id;
        const backId = 2 * r.id + 1;
        // front->back
        cards.push({ id: frontId, front, back });
        // back->front
        cards.push({ id: backId, front: back, back: front });
      }
      return cards;
    }

    let allCards = [];
    let currentFront = "";
    let currentBack = "";

    function drawCard() {
      if (allRecords.length === 0) {
        alert("No data in DB to draw from. Upload CSV or add text first.");
        return;
      }
      // Rebuild allCards
      allCards = buildAllCards();

      // Hide back & search buttons
      document.getElementById("backTextContainer").style.display = "none";
      document.getElementById("googleSearchButtons").style.display = "none";

      // Weighted pick
      const rand = cryptoRand();
      let chosenBucket = (rand < state.b1Prob) ? "b1" : "b2";
      if (getTotalFreq(state[chosenBucket]) === 0) {
        chosenBucket = (chosenBucket === "b1") ? "b2" : "b1";
      }
      if (getTotalFreq(state[chosenBucket]) === 0) {
        alert("No cards to draw from either bucket.");
        return;
      }

      const selectedId = weightedPick(state[chosenBucket]);
      lastDrawnId = selectedId;

      if (!(selectedId in state.b1)) {
        state.b1[selectedId] = 1;
        state.uniqueBucket1Count++;
      } else {
        state.b1[selectedId]++;
      }
      if (selectedId in state.b2) {
        state.b2[selectedId] = Math.max(0, state.b2[selectedId] - 1);
        if (state.b2[selectedId] === 0) {
          delete state.b2[selectedId];
        }
      }

      saveBucketState();
      updateDisplay();
      populateBucketLists();

      const card = allCards.find(c => c.id === selectedId);
      if (!card) {
        alert("Something went wrong: card not found.");
        return;
      }
      currentFront = card.front;
      currentBack = card.back;

      const frontEl = document.getElementById("frontText");
      const backEl = document.getElementById("backText");
      frontEl.innerText = currentFront;
      backEl.innerText = currentBack;
      adjustFontSize(frontEl, currentFront);
      adjustFontSize(backEl, currentBack);

      addToHistory(selectedId);
      populateHistoryList();
    }

    function revealAnswer() {
      document.getElementById("backTextContainer").style.display = "block";
      document.getElementById("googleSearchButtons").style.display = "block";
    }

    function undoLastDraw() {
      if (lastDrawnId == null) {
        alert("No recent draw to undo!");
        return;
      }
      if (!(lastDrawnId in state.b1)) {
        alert("Cannot undo: card not found in Bucket 1.");
        return;
      }
      state.b1[lastDrawnId]--;
      if (state.b1[lastDrawnId] <= 0) {
        delete state.b1[lastDrawnId];
        state.uniqueBucket1Count--;
      }
      if (lastDrawnId in state.b2) {
        state.b2[lastDrawnId]++;
      } else {
        state.b2[lastDrawnId] = 1;
      }
      // Remove from history
      state.drawHistory.shift();

      lastDrawnId = null;
      saveBucketState();
      updateDisplay();
      populateBucketLists();
      populateHistoryList();
      showToast("Last draw undone.");
    }

    // Copy Buttons
    function copyFrontText() {
      if (!currentFront) return;
      navigator.clipboard.writeText(currentFront)
        .then(() => showToast("Front card copied!"))
        .catch(() => alert("Unable to copy front text."));
    }
    function copyBackText() {
      if (!currentBack) return;
      navigator.clipboard.writeText(currentBack)
        .then(() => showToast("Back card copied!"))
        .catch(() => alert("Unable to copy back text."));
    }

    // Open as Link
    function openFrontAsLink() {
      if (!currentFront) return;
      window.open(currentFront, "_blank");
    }
    function openBackAsLink() {
      if (!currentBack) return;
      window.open(currentBack, "_blank");
    }

    // Searching
    function googleSearchFront() {
      if (!currentFront) return;
      window.open("https://www.google.com/search?q=" + encodeURIComponent(currentFront), "_blank");
    }
    function googleSearchBack() {
      if (!currentBack) return;
      window.open("https://www.google.com/search?q=" + encodeURIComponent(currentBack), "_blank");
    }
    function chatGPTSearchFront() {
      if (!currentFront) return;
      window.open("https://chat.openai.com/?q=" + encodeURIComponent(currentFront), "_blank");
    }
    function chatGPTSearchBack() {
      if (!currentBack) return;
      window.open("https://chat.openai.com/?q=" + encodeURIComponent(currentBack), "_blank");
    }
    function jishoSearchFront() {
      if (!currentFront) return;
      window.open("https://jisho.org/search/" + encodeURIComponent(currentFront), "_blank");
    }
    function jishoSearchBack() {
      if (!currentBack) return;
      window.open("https://jisho.org/search/" + encodeURIComponent(currentBack), "_blank");
    }

    function adjustFontSize(element, text) {
      const length = text.length;
      if (length <= 3) {
        element.style.fontSize = "3rem";
      } else if (length <= 10) {
        element.style.fontSize = "2.5rem";
      } else if (length <= 30) {
        element.style.fontSize = "2rem";
      } else {
        element.style.fontSize = "1.25rem";
      }
    }

    // History
    function addToHistory(cardId) {
      const ts = new Date().toLocaleString();
      const card = allCards.find(c => c.id === cardId);
      if (!card) return;
      const entry = {
        id: cardId,
        front: card.front,
        back: card.back,
        timestamp: ts
      };
      state.drawHistory.unshift(entry);
      while (state.drawHistory.length > historyLimit) {
        state.drawHistory.pop();
      }
    }
    function populateHistoryList() {
      const historyList = document.getElementById("historyList");
      historyList.innerHTML = "";
      for (let h of state.drawHistory) {
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.innerHTML = `<strong>${h.timestamp}:</strong> ${h.front} → ${h.back}`;
        historyList.appendChild(li);
      }
    }

    // Bucket lists
    function populateBucketLists() {
      allCards = buildAllCards();
      const b1List = document.getElementById("bucket1List");
      const b2List = document.getElementById("bucket2List");
      b1List.innerHTML = "";
      b2List.innerHTML = "";

      for (let cardId in state.b1) {
        const freq = state.b1[cardId];
        const card = allCards.find(c => c.id === Number(cardId));
        if (!card) continue;
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.textContent = `${card.front} → ${card.back} (Freq: ${freq})`;
        b1List.appendChild(li);
      }
      for (let cardId in state.b2) {
        const freq = state.b2[cardId];
        const card = allCards.find(c => c.id === Number(cardId));
        if (!card) continue;
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.textContent = `${card.front} → ${card.back} (Freq: ${freq})`;
        b2List.appendChild(li);
      }

      document.getElementById("bucket1Freq").innerText = getTotalFreq(state.b1);
      document.getElementById("bucket2Freq").innerText = getTotalFreq(state.b2);
    }

    // Gauges
    function updateDisplay() {
      allCards = buildAllCards();
      const totalCards = allCards.length;
      const fraction = (state.uniqueBucket1Count / totalCards) * 100;
      const fraction2 = 100 - fraction;

      const r1Gauge = document.getElementById("review1Gauge");
      const r1Text = document.getElementById("review1Text");
      const r2Gauge = document.getElementById("review2Gauge");
      const r2Text = document.getElementById("review2Text");

      r1Gauge.value = fraction.toFixed(2);
      r1Text.innerText = fraction.toFixed(2) + "%";
      r2Gauge.value = fraction2.toFixed(2);
      r2Text.innerText = fraction2.toFixed(2) + "%";
    }

    // Probability slider
    function updateProbabilities() {
      const sliderVal = parseInt(document.getElementById("probSlider").value);
      state.b1Prob = sliderVal / 100;
      state.b2Prob = 1 - state.b1Prob;
      document.getElementById("probBucket1").innerText = (state.b1Prob * 100).toFixed(0) + "%";
      document.getElementById("probBucket2").innerText = (state.b2Prob * 100).toFixed(0) + "%";
      saveBucketState();
    }

    function getTotalFreq(bucket) {
      return Object.values(bucket).reduce((acc, val) => acc + val, 0);
    }
    function weightedPick(bucketObj) {
      const entries = Object.entries(bucketObj);
      const total = entries.reduce((acc, [_, freq]) => acc + freq, 0);
      const randVal = Math.floor(cryptoRand() * total);
      let sum = 0;
      for (let [key, freq] of entries) {
        sum += freq;
        if (randVal < sum) {
          return Number(key);
        }
      }
      return Number(entries[entries.length - 1][0]);
    }
    function cryptoRand() {
      const arr = new Uint32Array(1);
      window.crypto.getRandomValues(arr);
      return arr[0] / (0xffffffff + 1);
    }

    // Export/Import/Reset bucket arrangement
    function exportState() {
      const str = JSON.stringify(state, null, 2);
      const blob = new Blob([str], { type: "application/json" });
      const now = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `flashcard-buckets-${now}.json`;

      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();

      showToast("Bucket state exported successfully.");
    }
    function importState() {
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json,application/json";
      fileInput.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = event => {
            try {
              const imported = JSON.parse(event.target.result);
              state = { ...state, ...imported };
              saveBucketState();
              updateDisplay();
              populateBucketLists();
              populateHistoryList();
              showToast("Bucket state imported successfully.");
            } catch (err) {
              alert("Invalid JSON file.");
            }
          };
          reader.readAsText(file);
        }
      };
      fileInput.click();
    }
    function resetBuckets(fully = false) {
      if (!fully && !confirm("Reset bucket arrangement? (This will not delete your IndexedDB data, only the 'review progress')")) return;
      state = {
        b1: {},
        b2: {},
        uniqueBucket1Count: 0,
        b1Prob: state.b1Prob,
        b2Prob: state.b2Prob,
        drawHistory: []
      };
      // Rebuild allCards from allRecords
      allCards = buildAllCards();
      // Put everything in b2 with freq=1
      for (let card of allCards) {
        state.b2[card.id] = 1;
      }
      saveBucketState();
      updateDisplay();
      populateBucketLists();
      populateHistoryList();
      if (!fully) {
        showToast("Buckets reset. All items are back in Bucket2.");
      }
    }

    function saveBucketState() {
      localStorage.setItem(localBucketsKey, JSON.stringify(state));
    }
    function loadBucketState() {
      const raw = localStorage.getItem(localBucketsKey);
      if (raw) {
        try {
          const parsed = JSON.parse(raw);
          state = { ...state, ...parsed };
        } catch(e) {
          console.warn("Failed to parse saved bucket state, ignoring.");
        }
      }
    }

    /****************************************************
     *                MISC / UI HELPERS
     ****************************************************/
    function showToast(msg) {
      const toastContainer = document.getElementById("toastContainer");
      const toastEl = document.createElement("div");
      toastEl.className = "toast align-items-center text-bg-primary border-0";
      toastEl.setAttribute("role", "alert");
      toastEl.setAttribute("aria-live", "assertive");
      toastEl.setAttribute("aria-atomic", "true");
      toastEl.style.minWidth = "200px";

      toastEl.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">${msg}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto"
                  data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      `;
      toastContainer.appendChild(toastEl);
      const bsToast = new bootstrap.Toast(toastEl);
      bsToast.show();
      toastEl.addEventListener("hidden.bs.toast", () => {
        toastContainer.removeChild(toastEl);
      });
    }

    async function getRandomColor() {
      try {
        const response = await fetch("pantone-colors.json");
        if (!response.ok) throw new Error("No pantone-colors.json found");
        const pantoneData = await response.json();
        const { names, values } = pantoneData;
        if (!names || !values || names.length !== values.length) {
          throw new Error("Invalid pantone-colors.json format");
        }
        const arr = new Uint32Array(1);
        window.crypto.getRandomValues(arr);
        const rand = arr[0] / (0xFFFFFFFF + 1);
        const randomIndex = Math.floor(rand * names.length);
        document.body.style.backgroundColor = values[randomIndex];
        const colorDisplay = document.getElementById("pantoneColorDisplay");
        if (colorDisplay) {
          colorDisplay.textContent = `${names[randomIndex]} (${values[randomIndex]})`;
        }
      } catch (error) {
        document.body.style.backgroundColor = "#ffffff";
      }
    }
  </script>
</body>
</html>
