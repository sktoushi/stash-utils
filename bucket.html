<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Random URL Picker with Customizable Settings</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Existing CSS styles remain unchanged */
        body {
            background-color: #f8f9fa;
        }
        body.dark-mode {
            background-color: #343a40;
            color: #f8f9fa;
        }
        .container {
            max-width: 900px;
            margin-top: 30px;
        }
        .btn-draw {
            width: 100%;
            margin-bottom: 20px;
        }
        .slider-container, .input-container {
            margin-bottom: 20px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
        }
        .btn-export {
            margin-top: 10px;
        }
        .gauge-container {
            margin-bottom: 20px;
        }
        .bucket-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .history-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .dark-mode .card {
            background-color: #495057;
            color: #f8f9fa;
        }
        .dark-mode .form-control, .dark-mode .form-select {
            background-color: #6c757d;
            color: #f8f9fa;
            border: 1px solid #ced4da;
        }
        .dark-mode .btn-primary {
            background-color: #0d6efd;
            border-color: #0d6efd;
        }
        .dark-mode .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
        }
        /* Custom scrollbar for dark mode */
        body.dark-mode ::-webkit-scrollbar {
            width: 8px;
        }
        body.dark-mode ::-webkit-scrollbar-track {
            background: #343a40;
        }
        body.dark-mode ::-webkit-scrollbar-thumb {
            background: #6c757d;
            border-radius: 4px;
        }
    </style>
    <script>
        // Global Variables
        let bucketFiles = []; // To be loaded from bucket-declaration.json
        let allInitialFiles = {}; // Stores initialFiles for all targets
        let unifiedState = {}; // Unified state object for all targets (excluding b2)
        const unifiedStorageKey = 'randomUrlPickerState'; // Unified localStorage key
        let bucketStateDifferences = {}; // Differences from bucket-state.json
        let drawHistoryLimit = 5; // Maximum number of history items per target
        let currentTarget = ''; // Current target based on URL parameter
        let currentTargetState = {}; // State for the current target
        let lastDrawnId = null; // To track last drawn item for undo

        /**
         * Function to get a secure random number between 0 (inclusive) and 1 (exclusive)
         */
        function getSecureRandomNumber() {
            const array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            return array[0] / (0xFFFFFFFF + 1);
        }

        /**
         * Function to parse URL parameters
         */
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        /**
         * Function to fetch JSON data
         * @param {string} filename - Name of the JSON file to fetch
         * @returns {Promise<Object>} - Parsed JSON data
         */
        async function fetchJSON(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Unable to fetch ${filename}`);
                }
                return await response.json();
            } catch (error) {
                alert(`Error: ${error.message}`);
                return null;
            }
        }

        /**
         * Function to load bucket-declaration.json
         */
        async function loadBucketDeclaration() {
            const declarationData = await fetchJSON('bucket-declaration.json');
            if (declarationData && Array.isArray(declarationData.buckets)) {
                bucketFiles = declarationData.buckets;
            } else {
                alert('Error: Invalid or missing "buckets" array in bucket-declaration.json.');
                bucketFiles = [];
            }
        }

        /**
         * Function to load all bucket-xxx.json files
         */
        async function loadAllBuckets() {
            const loadPromises = bucketFiles.map(bucket => fetchJSON(`${bucket}.json`));
            const results = await Promise.all(loadPromises);
            bucketFiles.forEach((bucket, index) => {
                if (results[index] && results[index].initialFiles) {
                    allInitialFiles[bucket] = results[index].initialFiles;
                } else {
                    allInitialFiles[bucket] = [];
                }
            });
        }

        /**
         * Function to load bucket-state.json (differences)
         */
        async function loadBucketStateDifferences() {
            const stateData = await fetchJSON('bucket-state.json');
            if (stateData) {
                bucketStateDifferences = stateData;
            } else {
                bucketStateDifferences = {};
            }
        }

        /**
         * Function to merge initialFiles with state differences
         */
        function mergeState() {
            // Load unified state from localStorage if available
            const storedState = JSON.parse(localStorage.getItem(unifiedStorageKey));
            if (storedState) {
                unifiedState = storedState;
            } else {
                unifiedState = {};
            }

            // Iterate through all bucket files to initialize or update their states
            for (const bucket of bucketFiles) {
                // Initialize state if not present
                if (!unifiedState[bucket]) {
                    unifiedState[bucket] = {
                        b1: {},
                        uniqueBucket1Count: 0,
                        b1Prob: 0.66,
                        b2Prob: 0.34,
                        defaultFrequency: 1,
                        urlPrefix: '',
                        urlSuffix: '',
                        drawHistory: []
                    };
                }

                // Apply differences from bucket-state.json if available
                if (bucketStateDifferences[bucket]) {
                    const differences = bucketStateDifferences[bucket];
                    unifiedState[bucket] = {
                        ...unifiedState[bucket],
                        ...differences,
                        drawHistory: [
                            ...(differences.drawHistory || []),
                            ...(unifiedState[bucket].drawHistory || [])
                        ].slice(0, drawHistoryLimit)
                    };
                }

                // Ensure that b1 and drawHistory have default structures
                unifiedState[bucket].b1 = unifiedState[bucket].b1 || {};
                unifiedState[bucket].drawHistory = unifiedState[bucket].drawHistory || {};
            }

            // Save the unified state back to localStorage
            localStorage.setItem(unifiedStorageKey, JSON.stringify(unifiedState));
        }

        /**
         * Function to initialize the state for the current target
         */
        function initializeCurrentTargetState() {
            if (!(currentTarget in unifiedState)) {
                // If the current target is not in unifiedState, initialize it
                unifiedState[currentTarget] = {
                    b1: {},
                    uniqueBucket1Count: 0,
                    b1Prob: 0.66,
                    b2Prob: 0.34,
                    defaultFrequency: 1,
                    urlPrefix: '',
                    urlSuffix: '',
                    drawHistory: []
                };
                // b2 is inferred from initialFiles and remains untouched
                saveState();
            }
            currentTargetState = { ...unifiedState[currentTarget] };
        }

        /**
         * Function to save the current state to unified localStorage
         */
        function saveState() {
            unifiedState[currentTarget] = { ...currentTargetState };
            localStorage.setItem(unifiedStorageKey, JSON.stringify(unifiedState));
        }

        /**
         * Main function to handle loading buckets and initializing app
         */
        async function main() {
            loadDarkMode();
            const targetParam = getUrlParameter('target');
            const readOnlyMode = !targetParam; // Check if the target is absent

            if (readOnlyMode) {
                // In read-only mode, load all buckets and proceed without state changes
                await loadBucketDeclaration();
            } else {
                // If target is present, load only the specified buckets
                const targetBuckets = targetParam.split(',');
                bucketFiles = targetBuckets;
            }

            // Load bucket files and state differences, then merge them
            await loadAllBuckets();
            await loadBucketStateDifferences();
            mergeState();

            // Initialize current target or all targets if in readOnlyMode
            if (readOnlyMode) {
                currentTargetState = { b1: {}, uniqueBucket1Count: 0, drawHistory: [] };
            } else {
                initializeCurrentTargetState();
            }

            // Update the display and initialize sliders and bucket lists
            updateDisplay();
            initializeSlider();
            populateBucketLists();
            populateHistoryList();
        }

        /**
         * Function to pick a random URL based on the current state
         */
        function pickRandom() {
            updateProbabilities(); // Ensure probabilities are up to date
            const readOnlyMode = !getUrlParameter('target'); // Check if we're in read-only mode

            if (readOnlyMode) {
                // Random selection from all buckets in read-only mode without altering state
                const randBucketIndex = Math.floor(getSecureRandomNumber() * bucketFiles.length);
                const bucket = bucketFiles[randBucketIndex];

                const availableItems = allInitialFiles[bucket].map(file => ({
                    id: file[0],
                    url: file[1],
                    remaining: file[2] || currentTargetState.defaultFrequency
                })).filter(item => item.remaining > 0);

                if (availableItems.length === 0) {
                    alert('No URLs available in selected bucket.');
                    return;
                }

                // Pick a random URL from available items
                const randomPick = Math.floor(getSecureRandomNumber() * availableItems.length);
                const selectedItem = availableItems[randomPick];

                // Open the selected URL without modifying state or history
                window.open(selectedItem.url, '_blank');
                showToast(`Opened URL: ${selectedItem.url}`);
            } else {
                // Existing behavior for normal mode
                const rand = getSecureRandomNumber();
                let selectedBucket = rand < currentTargetState.b1Prob ? 'b1' : 'b2';

                let availableBuckets = [];
                if (selectedBucket === 'b1' && getAvailableFreq('b1') > 0) {
                    availableBuckets.push('b1');
                }
                if (selectedBucket === 'b2' && getAvailableFreq('b2') > 0) {
                    availableBuckets.push('b2');
                }

                if (availableBuckets.length === 0) {
                    alert('All URLs have been drawn!');
                    return;
                }

                selectedBucket = rand < currentTargetState.b1Prob ? 'b1' : 'b2';

                const availableFreq = getAvailableFreq(selectedBucket);
                if (availableFreq === 0) {
                    alert(`Bucket ${selectedBucket.toUpperCase()} is empty!`);
                    return;
                }

                const availableItems = allInitialFiles[currentTarget].map(file => {
                    const id = file[0];
                    const freq = file[2] !== null ? file[2] : currentTargetState.defaultFrequency;
                    const drawn = currentTargetState.b1[id] || 0;
                    const remaining = Math.max(0, freq - drawn);
                    return { id, url: file[1], remaining };
                }).filter(item => item.remaining > 0);

                if (availableItems.length === 0) {
                    alert(`Bucket ${selectedBucket.toUpperCase()} has no available URLs.`);
                    return;
                }

                const randomPick = Math.floor(getSecureRandomNumber() * availableItems.length);
                const selectedItem = availableItems[randomPick];

                window.open(selectedItem.url, '_blank');
                showToast(`Opened URL: ${selectedItem.url}`);

                if (selectedBucket === 'b1') {
                    if (!currentTargetState.b1[selectedItem.id]) {
                        currentTargetState.b1[selectedItem.id] = 1;
                        currentTargetState.uniqueBucket1Count += 1;
                    } else {
                        currentTargetState.b1[selectedItem.id] += 1;
                    }
                }

                saveState();
            }
        }

        /**
         * Function to toggle dark mode
         */
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
        }

        /**
         * Function to load dark mode preference
         */
        function loadDarkMode() {
            const isDark = localStorage.getItem('darkMode') === 'true';
            if (isDark) {
                document.body.classList.add('dark-mode');
            }
        }

        /**
         * Function to show toast notifications
         */
        function showToast(message) {
            const toastContainer = document.getElementById('toastContainer');
            const toastEl = document.createElement('div');
            toastEl.className = 'toast align-items-center text-bg-primary border-0';
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');

            toastEl.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;

            toastContainer.appendChild(toastEl);
            const bsToast = new bootstrap.Toast(toastEl);
            bsToast.show();

            toastEl.addEventListener('hidden.bs.toast', () => {
                toastContainer.removeChild(toastEl);
            });
        }

        window.onload = main;
    </script>
</head>
<body>
    <div class="container">
        <h1 class="text-center">Random URL Picker</h1>

        <!-- Theme Toggle -->
        <div class="text-end mb-3">
            <button class="btn btn-secondary" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                <i class="fas fa-moon"></i> Dark Mode
            </button>
        </div>

        <div class="input-container">
            <label class="form-label">URL Prefix:</label>
            <input type="text" class="form-control" id="urlPrefix" placeholder="Enter URL Prefix" title="Add a prefix to all URLs">
            <label class="form-label">URL Suffix:</label>
            <input type="text" class="form-control" id="urlSuffix" placeholder="Enter URL Suffix" title="Add a suffix to all URLs">
            <button class="btn btn-secondary mt-2" onclick="saveUrlPrefixSuffix()" title="Save URL Prefix and Suffix">
                Save URL Prefix/Suffix
            </button>
        </div>

        <div class="input-container">
            <label class="form-label">Default Frequency:</label>
            <div class="input-group">
                <input type="number" class="form-control" id="defaultFrequency" value="1" min="1" disabled title="Set default frequency for new items">
                <button class="btn btn-secondary" onclick="toggleDefaultFrequency()" title="Edit Default Frequency">
                    <i class="fas fa-edit"></i> Edit
                </button>
                <button class="btn btn-primary" onclick="saveDefaultFrequency()" title="Save Default Frequency">
                    <i class="fas fa-save"></i> Save
                </button>
            </div>
        </div>

        <div class="slider-container">
            <label for="probSlider" class="form-label">Adjust Probabilities:</label>
            <input type="range" class="form-range" id="probSlider" min="0" max="100" value="66" oninput="updateProbabilities()" title="Adjust the probability of selecting from Bucket 1">
            <div class="slider-label">
                <span>Bucket 1: <span id="probBucket1">66%</span></span>
                <span>Bucket 2: <span id="probBucket2">34%</span></span>
            </div>
        </div>

        <button class="btn btn-primary btn-draw" onclick="pickRandom()" title="Draw a random URL">
            <i class="fas fa-random"></i> Draw and Open URL
        </button>

        <button class="btn btn-warning btn-draw" onclick="undoLastDraw()" title="Undo the last draw">
            <i class="fas fa-undo"></i> Undo Last Draw
        </button>

        <!-- Review Gauges -->
        <div class="gauge-container">
            <label for="review1Gauge" class="form-label">Review1 (Unique Bucket1 Items / Initial Bucket2 Total):</label>
            <progress id="review1Gauge" class="form-range w-100" value="0" max="100" aria-label="Review1 Gauge"></progress>
            <div class="text-center">
                <span id="review1Text">0%</span>
            </div>
        </div>

        <div class="gauge-container">
            <label for="review2Gauge" class="form-label">Review2 (Initial Bucket2 Total - Unique Bucket1 Items):</label>
            <progress id="review2Gauge" class="form-range w-100" value="100" max="100" aria-label="Review2 Gauge"></progress>
            <div class="text-center">
                <span id="review2Text">100%</span>
            </div>
        </div>

        <!-- Bucket Lists -->
        <div class="row">
            <div class="col-md-6">
                <h5>Bucket 1 Total Frequency: <span id="bucket1Freq">0</span></h5>
                <ul class="list-group bucket-list" id="bucket1List" aria-label="Bucket 1 Items">
                    <!-- Bucket1 items will be populated here -->
                </ul>
            </div>
            <div class="col-md-6">
                <h5>Bucket 2 Total Frequency: <span id="bucket2Freq">0</span></h5>
                <ul class="list-group bucket-list" id="bucket2List" aria-label="Bucket 2 Items">
                    <!-- Bucket2 items will be populated here -->
                </ul>
            </div>
        </div>

        <!-- Draw History -->
        <div class="mt-4">
            <h5>Draw History (Last 5):</h5>
            <ul class="list-group history-list" id="historyList" aria-label="Draw History">
                <!-- History items will be populated here -->
            </ul>
        </div>

        <!-- Action Buttons -->
        <div class="text-center mt-4">
            <button class="btn btn-secondary btn-export" onclick="exportState()" title="Export current state as JSON">
                <i class="fas fa-file-export"></i> Export State
            </button>
            <button class="btn btn-secondary btn-export" onclick="importState()" title="Import state from a JSON file">
                <i class="fas fa-file-import"></i> Import State
            </button>
            <button class="btn btn-danger btn-export" onclick="resetState()" title="Reset all settings and states">
                <i class="fas fa-trash-alt"></i> Reset State
            </button>
        </div>

        <!-- Toast Container -->
        <div aria-live="polite" aria-atomic="true" class="position-relative">
            <div id="toastContainer" class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
                <!-- Toasts will be appended here -->
            </div>
        </div>

        <!-- Bootstrap JS and dependencies -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-wpsYrgENSMwvWDnK+0hqyc+8zhu+uZdzsOCS8KQmS1b2y2lZjY0Chvh6e+GD44G" crossorigin="anonymous"></script>
    </div>
</body>
</html>
