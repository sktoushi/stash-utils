<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- For mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Clairvoyance 2025</title>
  <!-- Bootstrap CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-ENjdO4Dr2bkBIFxQpeo3rSwQo4YBUf5D7Z3zUDav0KccN+SOf5I1rZ4pJZMUfE65"
    crossorigin="anonymous"
  >
  <!-- Font Awesome (optional, for icons) -->
  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    rel="stylesheet"
  >
  <style>
    body {
      background-color: #f8f9fa;
      transition: background-color 0.5s ease;
    }

    body.dark-mode {
      background-color: #343a40;
      color: #f8f9fa;
    }

    /* Dark mode card styling */
    body.dark-mode .card {
      background-color: #495057;
      color: #f8f9fa;
    }

    body.dark-mode .btn-close {
      filter: invert(1);
    }

    /* Dark-mode form controls */
    body.dark-mode .form-control,
    body.dark-mode .form-select {
      background-color: #6c757d;
      color: #f8f9fa;
      border: 1px solid #ced4da;
    }
    .scoreboard-table th,
    .scoreboard-table td {
      text-align: center;
    }

    /* Toast overrides for dark mode if desired */
    body.dark-mode .toast.text-bg-primary {
      background-color: #0d6efd !important;
      color: #fff;
    }

    /* Show Pantone color info in the top-right corner */
    #pantoneColorDisplay {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #ffffffcc;
      padding: 5px 10px;
      border-radius: 5px;
      font-weight: bold;
      z-index: 9999;
    }

    /* Custom scrollbar for dark mode */
    body.dark-mode ::-webkit-scrollbar {
      width: 8px;
    }
    body.dark-mode ::-webkit-scrollbar-track {
      background: #343a40;
    }
    body.dark-mode ::-webkit-scrollbar-thumb {
      background: #6c757d;
      border-radius: 4px;
    }
  </style>
</head>
<body>

  <!-- Pantone Color Display -->
  <div id="pantoneColorDisplay"></div>

  <div class="container py-4">

    <!-- Page Header & Dark Mode Toggle -->
    <div class="row mb-3">
      <div class="col-12 text-center">
        <h1 class="display-6 fw-bold text-primary">Clairvoyance 2025</h1>
      </div>
      <div class="col-12 text-end">
        <button class="btn btn-secondary" onclick="toggleDarkMode()" title="Toggle Dark Mode">
          <i class="fas fa-moon"></i> Dark Mode
        </button>
      </div>
    </div>

    <!-- Buttons Row -->
    <div class="row mb-4 text-center">
      <div class="col">
        <div class="btn-group" role="group">
          <button id="helpBtn" class="btn btn-info">Help</button>
          <button id="startBtn" class="btn btn-primary">Start Game</button>
          <button id="quitBtn" class="btn btn-danger" disabled>Quit</button>
        </div>
      </div>
    </div>

    <!-- Game Area -->
    <div id="gameArea" class="row d-none">
      <div class="col-12 col-md-8 col-lg-6 mx-auto">
        <div class="card shadow-sm p-3 mb-4">
          <p id="drawStatus" class="fw-bold">Draws left: 100</p>
          <form id="guessForm" class="row g-2 mb-3">
            <div class="col-auto">
              <label for="guessInput" class="visually-hidden">Your Guess</label>
              <input
                type="text"
                class="form-control"
                id="guessInput"
                placeholder="Enter your guess (1 char)"
                maxlength="1"
                required
              >
            </div>
            <div class="col-auto">
              <button type="submit" class="btn btn-success">Submit Guess</button>
            </div>
          </form>
          <p class="mb-0">Score: <span id="currentScore">0</span></p>
        </div>
      </div>
    </div>

    <!-- Results Area -->
    <div id="resultArea" class="row d-none">
      <div class="col-12 col-md-10 col-lg-8 mx-auto">
        <div class="card shadow-sm p-3">
          <h3 class="text-success">Game Over</h3>
          <p id="finalMessage"></p>
          <!-- Daily Stats (up to 30 days) -->
          <div id="dailyStats" class="mt-4"></div>
          <!-- Leaderboard -->
          <h4 class="mt-4 text-secondary">Leaderboard (Top 15 Scores, Last 30 Days)</h4>
          <div id="leaderboard" class="table-responsive"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS Bundle (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+1D09tJzj6I2OMGV7KpP0N1pM9j7+"
    crossorigin="anonymous">
  </script>

  <!-- ========== Script for Game Logic & IndexedDB (Unchanged Functionality) ========== -->
  <script>
    // ========== Dark Mode Handling ==========
    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('darkMode', isDark);
    }
    function loadDarkModePreference() {
      const isDark = localStorage.getItem('darkMode') === 'true';
      if (isDark) {
        document.body.classList.add('dark-mode');
      }
    }

    // ========== Pantone Background Color ==========
    let lastPantoneColor = '#ffffff';
    async function applyRandomPantoneColor() {
      try {
        const response = await fetch('pantone-colors.json');
        const data = await response.json();
        const { names, values } = data;
        if (!names || !values || names.length !== values.length) {
          throw new Error('Invalid pantone-colors.json format.');
        }
        // pick a random index
        const randIndex = Math.floor(Math.random() * names.length);
        const chosenName = names[randIndex];
        const chosenColor = values[randIndex];
        document.body.style.backgroundColor = chosenColor;
        lastPantoneColor = chosenColor;
        // Update small display
        const colorDisplay = document.getElementById('pantoneColorDisplay');
        colorDisplay.textContent = `${chosenName} (${chosenColor})`;
      } catch (err) {
        console.error('Error fetching pantone-colors.json:', err);
        // fallback
        document.body.style.backgroundColor = '#ffffff';
      }
    }

    // ========== IndexedDB Setup ==========
    const DB_NAME = 'RandomCharacterGameDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'scores';  // store final score results
    let userFinalScore = 0;       // track the user's newly-finished score for redirect logic

    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = function(e) {
          const db = e.target.result;
          if(!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, {
              keyPath: 'id',
              autoIncrement: true
            });
            store.createIndex('score', 'score', { unique: false });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };

        request.onsuccess = function(e) {
          resolve(e.target.result);
        };
        request.onerror = function(e) {
          reject(e.target.error);
        };
      });
    }

    async function storeScore(score) {
      const db = await openDatabase();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const entry = {
          score,
          timestamp: Date.now()
        };
        store.add(entry);
        tx.oncomplete = () => { resolve(); };
        tx.onerror = (err) => { reject(err); };
      });
    }

    async function removeOldScores() {
      const now = Date.now();
      const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000;
      const cutoff = now - THIRTY_DAYS_MS;

      const db = await openDatabase();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.openCursor();

        req.onsuccess = function(e) {
          const cursor = e.target.result;
          if(cursor) {
            const record = cursor.value;
            if(record.timestamp < cutoff) {
              cursor.delete();
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = (err) => reject(err);
      });
    }

    async function getAllScores() {
      await removeOldScores();
      const db = await openDatabase();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          resolve(request.result || []);
        };
        request.onerror = (err) => {
          reject(err);
        };
      });
    }

    // ========== Game Logic ==========
    let lettersSubset = [];
    let probLetters = 0;
    let probNumbers = 0;
    let probSpecials = 0;
    let randomCoefficient1 = 0;
    let randomCoefficient2 = 0;

    const totalDraws = 100;
    let drawsLeft = totalDraws;
    let currentScore = 0;
    let correctCategoryCount = 0;
    let correctCharacterCount = 0;

    const allLetters = "abcdefghijklmnopqrstuvwxyz".split("");
    const numbers = "0123456789".split("");
    const specials = "!@#$%^&*()".split("");

    const helpBtn        = document.getElementById("helpBtn");
    const startBtn       = document.getElementById("startBtn");
    const quitBtn        = document.getElementById("quitBtn");
    const drawStatus     = document.getElementById("drawStatus");
    const guessForm      = document.getElementById("guessForm");
    const guessInput     = document.getElementById("guessInput");
    const currentScoreEl = document.getElementById("currentScore");
    const gameArea       = document.getElementById("gameArea");
    const resultArea     = document.getElementById("resultArea");
    const finalMessage   = document.getElementById("finalMessage");
    const dailyStatsEl   = document.getElementById("dailyStats");
    const leaderboardEl  = document.getElementById("leaderboard");

    const REDIRECT_URL = "https://sktoushi.github.io/stash-utils/bucket.html?target=bucket-finer-things-in-life";

    // Show Instructions Modal on Help button click
    helpBtn.addEventListener("click", () => {
      const instructionsModal = new bootstrap.Modal(document.getElementById("instructionsModal"));
      instructionsModal.show();
    });

    // Start the game
    startBtn.addEventListener("click", () => {
      initGame();
    });

    // Quit the game
    quitBtn.addEventListener("click", () => {
      endGame();
    });

    guessForm.addEventListener("submit", (e) => {
      e.preventDefault();
      if (drawsLeft <= 0) return;
      const userGuess = guessInput.value.trim();
      if (userGuess.length === 1) {
        makeDraw(userGuess.toLowerCase());
        guessInput.value = "";
        guessInput.focus();
      }
    });

    function initGame() {
      // Hide results area if visible
      resultArea.classList.add("d-none");
      // Show game area
      gameArea.classList.remove("d-none");
      quitBtn.disabled = false;

      drawsLeft = totalDraws;
      currentScore = 0;
      correctCategoryCount = 0;
      correctCharacterCount = 0;
      currentScoreEl.textContent = currentScore;
      drawStatus.textContent = `Draws left: ${drawsLeft}`;

      // Get random 10-letter subset
      lettersSubset = getRandomLetters(10);

      // Randomize category probabilities
      let w1 = Math.random();
      let w2 = Math.random();
      let w3 = Math.random();
      let sum = w1 + w2 + w3;
      probLetters = w1 / sum;
      probNumbers = w2 / sum;
      probSpecials = w3 / sum;

      // Random coefficients
      randomCoefficient1 = Math.random();
      do {
        randomCoefficient2 = Math.random();
      } while(randomCoefficient2 <= randomCoefficient1);
    }

    function makeDraw(userGuess) {
      const r = Math.random();
      let chosenCategory = "";
      let chosenChar = "";

      if (r < probLetters) {
        chosenCategory = "letter";
        chosenChar = lettersSubset[Math.floor(Math.random() * lettersSubset.length)];
      } else if (r < probLetters + probNumbers) {
        chosenCategory = "number";
        chosenChar = numbers[Math.floor(Math.random() * numbers.length)];
      } else {
        chosenCategory = "special";
        chosenChar = specials[Math.floor(Math.random() * specials.length)];
      }

      let userCategory = getCategory(userGuess);
      let pointsEarned = 0;

      if (userCategory === chosenCategory) {
        if (userGuess === chosenChar) {
          pointsEarned = randomCoefficient1 + randomCoefficient2;
          correctCharacterCount++;
          correctCategoryCount++;
        } else {
          pointsEarned = randomCoefficient1;
          correctCategoryCount++;
        }
      }

      currentScore += pointsEarned;
      currentScoreEl.textContent = currentScore.toFixed(4);

      drawsLeft--;
      drawStatus.textContent = `Draws left: ${drawsLeft}`;
      if (drawsLeft <= 0) {
        endGame();
      }
    }

    async function endGame() {
      quitBtn.disabled = true;
      gameArea.classList.add("d-none");
      resultArea.classList.remove("d-none");

      const drawsCompleted = totalDraws - drawsLeft;
      userFinalScore = currentScore;

      const summaryText = `
        You played ${drawsCompleted} draw(s).<br>
        Correct category guesses: <strong>${correctCategoryCount}</strong><br>
        Correct character guesses: <strong>${correctCharacterCount}</strong><br>
        Final Score: <strong>${currentScore.toFixed(4)}</strong>
      `;
      finalMessage.innerHTML = summaryText;

      await storeScore(currentScore);
      await buildDailyStatsAndLeaderboard();
    }

    function getRandomLetters(count) {
      let copy = [...allLetters];
      let chosen = [];
      for (let i = 0; i < count; i++) {
        let index = Math.floor(Math.random() * copy.length);
        chosen.push(copy[index]);
        copy.splice(index, 1);
      }
      return chosen;
    }

    function getCategory(ch) {
      if (lettersSubset.includes(ch)) {
        return "letter";
      } else if (numbers.includes(ch)) {
        return "number";
      } else if (specials.includes(ch)) {
        return "special";
      }
      return "unknown";
    }

    async function buildDailyStatsAndLeaderboard() {
      const allScores = await getAllScores();
      if(!allScores || allScores.length === 0) {
        dailyStatsEl.innerHTML = "<p>No game data yet.</p>";
        leaderboardEl.innerHTML = "<p>No game data yet.</p>";
        return;
      }

      let now = Date.now();
      let MS_PER_DAY = 86400000;
      let earliest = now - (30 * MS_PER_DAY);

      // Group scores by day
      let dailyMap = new Map();
      for(const record of allScores) {
        if(record.timestamp < earliest) continue;
        let dayStr = getDayString(record.timestamp);
        if(!dailyMap.has(dayStr)) {
          dailyMap.set(dayStr, []);
        }
        dailyMap.get(dayStr).push(record.score);
      }

      let sortedDays = Array.from(dailyMap.keys()).sort();
      let dailyAverages = [];
      for(let d of sortedDays) {
        let scoresArr = dailyMap.get(d);
        let sum = scoresArr.reduce((a,b) => a + b, 0);
        let avg = sum / scoresArr.length;
        dailyAverages.push({ day: d, avgScore: avg });
      }

      // Build daily averages table
      let statsHtml = `<h5 class="text-primary">Daily Averages (Last 30 Days)</h5>`;
      statsHtml += `
        <table class="table table-bordered table-hover scoreboard-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Average Score</th>
              <th>% Change from Prev Day</th>
            </tr>
          </thead>
          <tbody>
      `;
      for(let i = 0; i < dailyAverages.length; i++){
        let dayData = dailyAverages[i];
        let changeHtml = "-";
        if(i > 0) {
          let prevAvg = dailyAverages[i-1].avgScore;
          let diff = dayData.avgScore - prevAvg;
          let pctChange = (diff / prevAvg) * 100;
          if(isFinite(pctChange)) {
            changeHtml = pctChange.toFixed(2) + "%";
          }
        }
        statsHtml += `
          <tr>
            <td>${dayData.day}</td>
            <td>${dayData.avgScore.toFixed(4)}</td>
            <td>${changeHtml}</td>
          </tr>
        `;
      }
      statsHtml += `</tbody></table>`;
      dailyStatsEl.innerHTML = statsHtml;

      // Build leaderboard
      const sortedAllScores = allScores.sort((a,b) => b.score - a.score);
      const top15 = sortedAllScores.slice(0, 15);
      let leaderboardHtml = `
        <table class="table table-bordered table-hover scoreboard-table">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Score</th>
              <th>Date/Time</th>
            </tr>
          </thead>
          <tbody>
      `;
      top15.forEach((entry, idx) => {
        let dt = new Date(entry.timestamp).toLocaleString();
        leaderboardHtml += `
          <tr>
            <td>${idx+1}</td>
            <td>${entry.score.toFixed(4)}</td>
            <td>${dt}</td>
          </tr>
        `;
      });
      leaderboardHtml += `</tbody></table>`;
      leaderboardEl.innerHTML = leaderboardHtml;

      // Check redirect logic
      if(dailyAverages.length >= 2) {
        let latest = dailyAverages[dailyAverages.length - 1].avgScore;
        let prev   = dailyAverages[dailyAverages.length - 2].avgScore;
        if(latest > prev) {
          window.location.href = REDIRECT_URL;
          return;
        }
      }

      if(top15.length < 15) {
        window.location.href = REDIRECT_URL;
        return;
      } else {
        const fifteenthScore = top15[top15.length - 1].score;
        if(userFinalScore >= fifteenthScore) {
          window.location.href = REDIRECT_URL;
          return;
        }
      }
    }

    function getDayString(ts) {
      let d = new Date(ts);
      let year = d.getFullYear();
      let month = String(d.getMonth() + 1).padStart(2, '0');
      let day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // ========== Show/Hide Instructions in a Modal ==========
    // We’ll attach a hidden modal in the body (below).
    // The “Help” button toggles it via code (helpBtn.addEventListener).

    // ========== On Page Load ==========
    window.addEventListener('DOMContentLoaded', async () => {
      loadDarkModePreference();
      await applyRandomPantoneColor();
    });
  </script>

  <!-- ========== Modal for Instructions ========== -->
  <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="instructionsModalLabel">Instructions</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="lead mb-0">
            <strong>Instructions:</strong><br>
            1. We have 3 categories: <em>lowercase letters</em>, <em>numbers</em>, <em>special characters</em>.<br>
            2. Each category has a random probability weight; they add to 1.<br>
            3. For letters, we use a random subset of <strong>10 distinct lowercase</strong> letters.<br>
            4. We draw 100 random characters based on the probability weights.<br>
            5. Your job: guess the next character on each draw. You get points for correct predictions:
               <ul class="mb-0">
                 <li>If you guess the correct category, you get <code>randomCoefficient1</code>.</li>
                 <li>If you guess the exact character, you get <code>randomCoefficient1 + randomCoefficient2</code> (with <code>randomCoefficient2 &gt; randomCoefficient1</code>).</li>
               </ul>
            6. You may quit any time to see your results early.<br>
            7. Your final score and timestamp will be stored (only for the last 30 days).<br>
            8. If today's daily average beats yesterday's, or you place in the Top 15 scoreboard, an immediate redirect occurs.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast Container (if you ever want to show custom toasts) -->
  <div aria-live="polite" aria-atomic="true" class="position-relative">
    <div id="toastContainer" class="position-fixed bottom-0 end-0 p-3" style="z-index: 11;">
      <!-- Toasts can be appended here dynamically -->
    </div>
  </div>

</body>
</html>
