<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random CSV Redirect (Weighted + Nested + Variables + Math)</title>
</head>
<body>
<script>
/* ------------------------------------------------------------------ */
/*  0.  SECURE RNG                                                    */
/* ------------------------------------------------------------------ */
/** Returns a cryptographically-secure random number in [0, 1). */
function getSecureRandomNumber() {
  const array = new Uint32Array(1);
  window.crypto.getRandomValues(array);
  return array[0] / (0xFFFFFFFF + 1);
}

/* ------------------------------------------------------------------ */
/*  0A.  GLOBAL VARIABLE STORE (persists across every CSV)            */
/* ------------------------------------------------------------------ */
const globalVariables = Object.create(null);

/* ------------------------------------------------------------------ */
/*  1.  STRING HELPERS                                                */
/* ------------------------------------------------------------------ */
function cleanCell(cell) {
  cell = cell.trim();
  return cell.replace(/^["']+|["']+$/g, '');
}

/* ------------------------------------------------------------------ */
/*  2.  CSV PARSING (RESPECTS QUOTES)                                 */
/* ------------------------------------------------------------------ */
function parseCsvLine(line) {
  const result = [];
  let curCell = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') {
      if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
        curCell += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (c === ',' && !inQuotes) {
      result.push(curCell);
      curCell = '';
    } else {
      curCell += c;
    }
  }
  result.push(curCell);
  return result;
}

/* ------------------------------------------------------------------ */
/*  3.  FISHER–YATES SHUFFLE                                          */
/* ------------------------------------------------------------------ */
function shuffle(array) {
  let currentIndex = array.length;
  while (currentIndex !== 0) {
    const randomIndex = Math.floor(getSecureRandomNumber() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] =
      [array[randomIndex], array[currentIndex]];
  }
  return array;
}

/* ------------------------------------------------------------------ */
/*  4.  VARIABLE SUPPORT  (WITH  MATH)                                */
/* ------------------------------------------------------------------ */
/**
 * Removes “variable” rows, updates the global store (incl. math eval),
 * then substitutes {placeholders} in the remaining rows.
 *
 * @param {string[][]} rows
 * @param {object}     store – usually `globalVariables`
 * @returns {string[][]} rows ready for normal processing
 */
function applyVariables(rows, store) {
  const keptRows     = [];
  const variableRows = [];

  /* 4.1  Separate variable rows from normal rows */
  rows.forEach(r => {
    if (r[0].trim() === 'variable' && r.length >= 2) {
      variableRows.push(r);
    } else {
      keptRows.push(r);
    }
  });

  /* 4.2  Resolve variables (allowing inter-dependencies + math) */
  const PLACEHOLDER_RE = /\{([^}]+)}/g;
  let iterations       = 0;

  while (variableRows.length && iterations < 25) {
    iterations++;

    for (let i = variableRows.length - 1; i >= 0; i--) {
      const [keyPart, ...rest] = variableRows[i][1].split('=');
      if (!keyPart || rest.length === 0) {
        variableRows.splice(i, 1);          // malformed → drop
        continue;
      }
      const key   = keyPart.trim();
      let  expr   = rest.join('=').trim();  // allow '=' inside value

      /* Substitute already-known variables */
      expr = expr.replace(PLACEHOLDER_RE, (m, p1) =>
        Object.prototype.hasOwnProperty.call(store, p1) ? store[p1] : m
      );

      /* If unresolved placeholders remain, try next iteration */
      if (PLACEHOLDER_RE.test(expr)) continue;

      /* Allow only safe characters: digits, + - * / ( ) whitespace */
      if (!/^[\d+\-*/().\s]+$/.test(expr)) {
        console.warn(`Unsafe expression in variable ${key}: ${expr}`);
        variableRows.splice(i, 1);
        continue;
      }

      /* Evaluate & round up (Math.ceil) */
      let value;
      try {
        value = Function('"use strict"; return (' + expr + ');')();
        if (typeof value !== 'number' || !isFinite(value)) {
          throw new Error('NaN/Inf');
        }
        value = Math.ceil(value);            // always round up
      } catch {
        console.warn(`Failed to evaluate expression for ${key}: ${expr}`);
        variableRows.splice(i, 1);
        continue;
      }

      store[key] = String(value);
      variableRows.splice(i, 1);             // resolved → remove
    }
  }

  /* Any still-unresolved variable rows: stash their raw value */
  variableRows.forEach(r => {
    const [keyPart, ...rest] = r[1].split('=');
    if (keyPart && rest.length && !Object.prototype.hasOwnProperty.call(store, keyPart.trim())) {
      store[keyPart.trim()] = rest.join('=').trim();
    }
  });

  /* 4.3  Substitute {vars} in remaining rows */
  const replacedRows = keptRows.map(row => row.map(cell =>
    cell.replace(PLACEHOLDER_RE, (m, p1) =>
      Object.prototype.hasOwnProperty.call(store, p1) ? store[p1] : m
    )
  ));

  return replacedRows;
}

/* ------------------------------------------------------------------ */
/*  5.  FETCH AND PARSE A CSV FILE                                    */
/* ------------------------------------------------------------------ */
async function fetchCSV(csvFilename, store = globalVariables) {
  console.log(`Attempting to fetch CSV: ${csvFilename}`);

  try {
    const response = await fetch(csvFilename);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV: ${response.status} ${response.statusText}`);
    }
    const csvText = await response.text();

    const lines = csvText
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    const parsedRows = lines.map(line =>
      parseCsvLine(line).map(cell => cleanCell(cell))
    );

    /* Variable extraction / substitution (with math) */
    const resolvedRows = applyVariables(parsedRows, store);

    /* Shuffle (weights are preserved) */
    shuffle(resolvedRows);
    return resolvedRows;

  } catch (error) {
    throw new Error('Error fetching CSV: ' + error.message);
  }
}

/* ------------------------------------------------------------------ */
/*  6.  WEIGHTED SELECTION                                            */
/* ------------------------------------------------------------------ */
function pickRowByWeight(rows) {
  const weightedRows = rows.map(r => {
    let w = parseInt(r[1], 10);
    if (isNaN(w) || w < 1) w = 1;
    return { row: r, weight: w };
  });

  const totalWeight = weightedRows.reduce((s, x) => s + x.weight, 0);

  if (totalWeight <= 0) {
    console.warn('Total weight ≤ 0 – falling back to uniform choice.');
    return rows[Math.floor(getSecureRandomNumber() * rows.length)];
  }

  let rand = getSecureRandomNumber() * totalWeight;
  for (const wr of weightedRows) {
    if (rand < wr.weight) return wr.row;
    rand -= wr.weight;
  }
  return weightedRows[weightedRows.length - 1].row; // Fallback
}

/* ------------------------------------------------------------------ */
/*  7.  ROW PROCESSING (RECURSIVE)                                    */
/* ------------------------------------------------------------------ */
async function processRows(rows, recursionDepth = 0) {
  if (recursionDepth > 2000) {
    document.body.textContent = 'Error: exceeded maximum CSV nesting depth.';
    return;
  }
  if (!rows.length) {
    document.body.textContent = 'CSV is empty or could not be parsed.';
    return;
  }

  const selectedRow = pickRowByWeight(rows);
  console.log('Selected row:', selectedRow);

  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    const url = selectedRow[2];
    console.log('Redirecting to link:', url);
    window.location.href = url;
  }

  else if (rowType === 'git-specific') {
    const username   = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueIds   = selectedRow[4].split('=')[1].split('_');
    const chosen     = issueIds[Math.floor(getSecureRandomNumber() * issueIds.length)];
    const finalUrl   = `https://github.com/${username}/${repository}/issues/${chosen}`;
    console.log('Redirecting to git-specific issue:', finalUrl);
    window.location.href = finalUrl;
  }

  else if (rowType === 'git-range') {
    const username   = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const [minStr, maxStr] = selectedRow[4].split('=')[1].split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);
    if (isNaN(min) || isNaN(max)) {
      document.body.textContent = 'Invalid range in "git-range" row.';
      return;
    }
    const n = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    const finalUrl = `https://github.com/${username}/${repository}/issues/${n}`;
    console.log('Redirecting to git-range issue:', finalUrl);
    window.location.href = finalUrl;
  }

  else if (rowType === 'csv') {
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      document.body.textContent = 'CSV type found but no filename specified.';
      return;
    }
    console.log('Nested CSV – fetching:', nestedCsv);
    try {
      const nestedRows = await fetchCSV(nestedCsv, globalVariables);
      await processRows(nestedRows, recursionDepth + 1);
    } catch (error) {
      document.body.textContent = error.message;
    }
  }

  else {
    document.body.textContent = 'Unknown row type: ' + rowType;
  }
}

/* ------------------------------------------------------------------ */
/*  8.  MAIN ENTRY POINT                                              */
/* ------------------------------------------------------------------ */
async function main() {
  const urlParams = new URLSearchParams(window.location.search);
  const target    = urlParams.get('target');

  if (!target) {
    document.body.textContent = 'No "target" parameter found (use ?target=file.csv).';
    return;
  }

  try {
    let rows = await fetchCSV(target, globalVariables);

    /* ---- Weight normalisation for explicit "null" cells ---------- */
    const nonNullVals = rows
      .map(r => (r[1] !== 'null' ? parseInt(r[1], 10) : NaN))
      .filter(v => !isNaN(v));

    if (nonNullVals.length > 0) {
      const minVal = Math.min(...nonNullVals);
      const maxVal = Math.max(...nonNullVals);
      for (let i = 0; i < rows.length; i++) {
        if (rows[i][1] === 'null') {
          const randVal = Math.floor(getSecureRandomNumber() * (maxVal - minVal + 1)) + minVal;
          rows[i][1] = String(randVal);
        }
      }
    }
    /* -------------------------------------------------------------- */

    await processRows(rows, 0);
  } catch (error) {
    document.body.textContent = 'Failed to process CSV: ' + error.message;
  }
}

window.onload = main;
</script>
</body>
</html>
