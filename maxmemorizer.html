<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Sentence Reconstruction Game</title>
  <!-- Bootstrap CSS (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <style>
    /* Ensure the reconstruction area is of modest size initially but can grow. */
    #workInProgress {
      width: 100%;
      min-height: 150px; /* modest initial height */
      overflow-wrap: break-word; /* handle long text gracefully */
    }

    /* Make sure choice buttons + progress appear inline for the current guess */
    .choice-buttons-inline {
      margin-left: 8px; 
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
    }
  </style>
</head>
<body class="bg-light">

<div class="container my-5">
  <h1 class="text-center mb-4">Sentence Reconstruction</h1>

  <!-- Text Area and Control Buttons (Initial View) -->
  <div id="initialView">
    <div class="mb-3">
      <label for="userInput" class="form-label fw-bold">Enter Your Passage:</label>
      <textarea
        class="form-control"
        id="userInput"
        rows="6"
        placeholder="Type or paste your paragraphs here..."
      ></textarea>
    </div>
    <button id="startBtn" class="btn btn-primary me-2">Start</button>
    <button id="clearBtn" class="btn btn-secondary">Clear All</button>
  </div>

  <!-- Game View (Hidden by Default) -->
  <div id="gameView" class="d-none">
    <p class="fw-bold" id="progressText">
      Reconstructing your text (lowercased) ...
    </p>
    <div class="mb-3">
      <!-- This is where the reconstructed text (plus choices inline) will appear -->
      <div id="workInProgress" class="p-3 border"></div>
    </div>

    <!-- Informational Feedback -->
    <div class="alert alert-info d-none" id="completionMsg"></div>

    <!-- Game Control Buttons -->
    <button id="restartBtn" class="btn btn-warning me-2">Restart</button>
    <button id="clearBtn2" class="btn btn-secondary">Clear All</button>
  </div>
</div>

<!-- Bootstrap Bundle JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /**
   * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
   */
  function getSecureRandomNumber() {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0] / (0xFFFFFFFF + 1);
  }

  // Grab references to DOM elements
  const initialView = document.getElementById('initialView');
  const gameView = document.getElementById('gameView');
  const startBtn = document.getElementById('startBtn');
  const clearBtn = document.getElementById('clearBtn');
  const userInput = document.getElementById('userInput');

  const progressText = document.getElementById('progressText');
  const workInProgress = document.getElementById('workInProgress');
  const completionMsg = document.getElementById('completionMsg');

  const restartBtn = document.getElementById('restartBtn');
  const clearBtn2 = document.getElementById('clearBtn2');

  // Some example 'skip' words/punctuation. Expand as needed.
  const skipWordsSet = new Set([
    'a', 'an', 'the', 'is', 'are', 'and', 'or', 'but', 'nor', 'yet', 'so', 'for',
    'of', 'in', 'to', 'by', 'with', 'from', '&', ',', '.', '?', '!', ':', ';',
    '"', '\'', '(', ')', '-', '_'
  ]);

  // We'll store metadata for each token in the input.
  // tokenData[i] = { original: string, cleaned: string, skip: boolean, guessed: boolean }
  let tokenData = [];

  // guessableTokens is an array of indices pointing into tokenData for those tokens that must be guessed
  let guessableTokens = [];

  // The current index within guessableTokens that the user is trying to guess
  let currentGuessIndex = 0;

  // We store the lowercased text so we can re-init if needed
  let originalText = '';

  // HELPER to remove leading/trailing punctuation but keep apostrophes if in middle
  function cleanWord(word) {
    let w = word.toLowerCase();
    // remove leading/trailing punctuation-like chars
    w = w.replace(/^[^a-z0-9']+|[^a-z0-9']+$/gi, '');
    return w;
  }

  // Shuffle array with cryptographically secure random
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(getSecureRandomNumber() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Build an array of four unique choices: the correct word, plus 3 distinct "wrong" words
  function getChoicesForCurrentToken() {
    if (currentGuessIndex >= guessableTokens.length) {
      return [];
    }

    const correctIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctIndex].cleaned;

    // Build a pool of all other guessable words (cleaned)
    const pool = guessableTokens
      .filter(i => i !== correctIndex)
      .map(i => tokenData[i].cleaned);

    // Remove duplicates from the pool if any
    const uniquePool = Array.from(new Set(pool));

    // Shuffle the pool
    shuffleArray(uniquePool);

    // Take the first 3 from that pool (if pool is smaller, take what we can)
    const wrongChoices = uniquePool.slice(0, 3);

    // Combine correct + wrong, shuffle again
    let allChoices = [correctClean, ...wrongChoices];
    shuffleArray(allChoices);

    return allChoices;
  }

  // Return a string with the entire paragraph, including any underscores and
  // the 4 choice buttons (plus progress) inline for the current word to guess.
  function buildSentenceHTML() {
    let html = '';
    // We'll figure out the 4 choices for the current token (if needed)
    const choices = getChoicesForCurrentToken();

    // Calculate progress if we have guessable tokens
    let progressPercent = '0.0';
    if (guessableTokens.length > 0) {
      progressPercent = ((currentGuessIndex / guessableTokens.length) * 100).toFixed(1);
    }

    for (let i = 0; i < tokenData.length; i++) {
      const t = tokenData[i];
      // If skip or guessed, display the token as-is
      if (t.skip || t.guessed) {
        html += `<span class="me-1">${t.original}</span>`;
      } else {
        // Not guessed yet. Check if this is the current token to guess
        const thisIsCurrent = (guessableTokens[currentGuessIndex] === i);

        if (thisIsCurrent) {
          // Show underscores
          let underscores = '_'.repeat(t.cleaned.length || 4);

          // Build the inline choice buttons + progress (the user wants them to the right).
          let buttonsHTML = '';
          choices.forEach(choice => {
            buttonsHTML += `<button 
              class="btn btn-outline-dark me-2 mb-1" 
              style="display:inline-block;"
              onclick="handleChoiceClick('${choice}')"
            >${choice}</button>`;
          });

          // The user wants a 5th disabled button showing progress
          buttonsHTML += `<button
              class="btn btn-secondary mb-1"
              style="display:inline-block;"
              disabled
            >
            ${progressPercent}%
            </button>`;

          html += `
            <span class="me-1" style="white-space: nowrap;">
              ${underscores}
              <span class="choice-buttons-inline">
                ${buttonsHTML}
              </span>
            </span>
          `;
        } else {
          // It's guessable but not the current token. Just show underscores
          let underscores = '_'.repeat(t.cleaned.length || 4);
          html += `<span class="me-1">${underscores}</span>`;
        }
      }
    }
    return html;
  }

  // Update the displayed text in #workInProgress
  function updateDisplayedText() {
    workInProgress.innerHTML = buildSentenceHTML();
  }

  // When the user clicks on one of the choice buttons
  function handleChoiceClick(chosenWord) {
    if (currentGuessIndex >= guessableTokens.length) {
      return;
    }

    const correctTokenIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctTokenIndex].cleaned;

    if (chosenWord === correctClean) {
      // Mark the token as guessed
      tokenData[correctTokenIndex].guessed = true;
      currentGuessIndex++;

      // Check if we've completed all guessable tokens
      if (currentGuessIndex === guessableTokens.length) {
        // Show final result
        completionMsg.textContent = 'You have successfully reconstructed the text!';
        completionMsg.classList.remove('d-none');
      }
    } 
    // If wrong, we do nothing except re-render. The buttons will re-shuffle in buildSentenceHTML
    updateDisplayedText();
  }

  // Start the game
  startBtn.addEventListener('click', () => {
    originalText = userInput.value.trim().toLowerCase();
    if (!originalText) {
      alert('Please enter some text first!');
      return;
    }

    // Hide initial view, show game view
    initialView.classList.add('d-none');
    gameView.classList.remove('d-none');

    // Split text into tokens by whitespace
    const rawTokens = originalText.split(/\s+/);

    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    // Build token data
    rawTokens.forEach(tok => {
      const cleaned = cleanWord(tok);
      const skip = skipWordsSet.has(cleaned) || !cleaned;
      tokenData.push({
        original: tok,   // stored as-lowercased
        cleaned: cleaned,
        skip: skip,
        guessed: false
      });
    });

    // Fill guessableTokens
    tokenData.forEach((t, idx) => {
      if (!t.skip) {
        guessableTokens.push(idx);
      } else {
        // skip-words are automatically "guessed"
        t.guessed = true;
      }
    });

    // Initial render
    updateDisplayedText();
  });

  // Restart the game (same text)
  restartBtn.addEventListener('click', () => {
    if (!originalText) return;

    // Reset guess state
    tokenData.forEach((t) => {
      if (!t.skip) t.guessed = false;
    });
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    updateDisplayedText();
  });

  // Clear all - reset the entire page to initial state
  function clearAllPage() {
    userInput.value = '';
    originalText = '';
    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    workInProgress.innerHTML = '';
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    initialView.classList.remove('d-none');
    gameView.classList.add('d-none');
  }

  clearBtn.addEventListener('click', clearAllPage);
  clearBtn2.addEventListener('click', clearAllPage);

  // Expose handleChoiceClick globally so inline onclick works
  window.handleChoiceClick = handleChoiceClick;
</script>
</body>
</html>
