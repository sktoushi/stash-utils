<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Sentence Reconstruction Game</title>
  <!-- Bootstrap CSS (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <style>
    /* Ensure the reconstruction area is of modest size initially but can grow. */
    #workInProgress {
      width: 100%;
      min-height: 150px; /* modest initial height */
      overflow-wrap: break-word; /* handle long text gracefully */
    }

    /* Make sure choice buttons + progress appear inline for the current guess */
    .choice-buttons-inline {
      margin-left: 8px;
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
    }
  </style>
</head>
<body class="bg-light">

<div class="container my-5">
  <h1 class="text-center mb-4">Sentence Reconstruction</h1>

  <!-- Text Area and Control Buttons (Initial View) -->
  <div id="initialView">
    <div class="mb-3">
      <label for="userInput" class="form-label fw-bold">Enter Your Passage:</label>
      <textarea
        class="form-control"
        id="userInput"
        rows="6"
        placeholder="Type or paste your paragraphs here..."
      ></textarea>
    </div>
    <button id="startBtn" class="btn btn-primary me-2">Start</button>
    <button id="clearBtn" class="btn btn-secondary">Clear All</button>
  </div>

  <!-- Extra Tools (Always Visible) -->
  <div id="extraTools" class="mb-5">
    <h5 class="mt-4">Extra Tools for Thorough Learning:</h5>
    <p class="text-muted">
      Below are optional features you might find useful while studying or analyzing your text.
      These tools remain available even if content is pre-loaded (e.g. via <code>?cardId=</code>).
    </p>

    <!-- Search ChatGPT Button -->
    <div class="mb-3">
      <button id="searchChatGPTBtn" class="btn btn-outline-success" onclick="searchChatGPT()">
        Search ChatGPT
      </button>
    </div>

    <!-- Additional features for thorough learning -->
    <button class="btn btn-info me-2 mb-2" onclick="summarizeText()">
      Summarize Text
    </button>
    <button class="btn btn-info me-2 mb-2" onclick="generateQuiz()">
      Generate Quick Quiz
    </button>
    <button class="btn btn-info me-2 mb-2" onclick="readAloudText()">
      Read Aloud (TTS)
    </button>
    <button class="btn btn-info mb-2" onclick="highlightKeywords()">
      Highlight Keywords
    </button>
  </div>

  <!-- Game View (Hidden by Default) -->
  <div id="gameView" class="d-none">
    <p class="fw-bold" id="progressText">
      Reconstructing your text ...
    </p>
    <div class="mb-3">
      <!-- This is where the reconstructed text (plus choices inline) will appear -->
      <div id="workInProgress" class="p-3 border"></div>
    </div>

    <!-- Informational Feedback -->
    <div class="alert alert-info d-none" id="completionMsg"></div>

    <!-- Game Control Buttons -->
    <button id="restartBtn" class="btn btn-warning me-2">Restart</button>
    <button id="clearBtn2" class="btn btn-secondary">Clear All</button>
  </div>
</div>

<!-- Bootstrap Bundle JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /********************************************************************
   *   URL Param helper
   ********************************************************************/
  function getUrlParameter(name) {
    name = name.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(window.location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
  }

  /********************************************************************
   *   Determine DB name from ?db=... (defaults to "myCsvDb_default")
   ********************************************************************/
  let dbNameFromParam = getUrlParameter('db').trim();
  if (!dbNameFromParam) {
    dbNameFromParam = "myCsvDb_default";
  }
  const DB_NAME = dbNameFromParam;
  const DB_VERSION = 1;
  const STORE_NAME = "records";
  let db = null;

  /**
   * Open (or create/upgrade) the shared IndexedDB database.
   */
  function openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onupgradeneeded = (event) => {
        db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, {
            keyPath: 'id',
            autoIncrement: true
          });
          store.createIndex('textIndex', 'text', { unique: true });
        }
      };
      request.onsuccess = (event) => {
        db = event.target.result;
        resolve(db);
      };
      request.onerror = (event) => {
        console.error("IndexedDB error:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * Insert lines into DB, skipping duplicates (used if the user does a manual "Start").
   */
  function addLinesToDb(lines) {
    return new Promise((resolve, reject) => {
      if (!db) {
        console.error("IndexedDB is not opened yet!");
        resolve(0);
        return;
      }
      let addedCount = 0;
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const textIndex = store.index("textIndex");

      let processedCount = 0;

      function processNext(i) {
        if (i >= lines.length) {
          resolve(addedCount);
          return;
        }
        const line = lines[i].trim();
        if (!line) {
          processedCount++;
          processNext(i + 1);
          return;
        }
        // Check duplicates
        const checkReq = textIndex.get(line);
        checkReq.onsuccess = () => {
          if (checkReq.result) {
            // Already in DB
            processedCount++;
            processNext(i + 1);
          } else {
            const addReq = store.add({ text: line });
            addReq.onsuccess = () => {
              addedCount++;
              processedCount++;
              processNext(i + 1);
            };
            addReq.onerror = () => {
              processedCount++;
              processNext(i + 1);
            };
          }
        };
        checkReq.onerror = () => {
          processedCount++;
          processNext(i + 1);
        };
      }
      processNext(0);

      tx.oncomplete = () => { /* done */ };
      tx.onerror = (err) => {
        console.error("Transaction error:", err);
        reject(err);
      };
    });
  }

  /********************************************************************
   * HELPER: Return a cryptographically secure random number [0..1)
   ********************************************************************/
  function getSecureRandomNumber() {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0] / (0xFFFFFFFF + 1);
  }

  /**
   * Build all front/back permutations for a single record text
   * (same logic used in Land Cruiser 300).
   */
  function generatePermutationsForRecord(recordId, recordText) {
    const attributes = recordText.split(",")
      .map(a => a.trim())
      .filter(a => a.length > 0);

    const results = [];
    let pairIndex = 0;
    for (let i = 0; i < attributes.length; i++) {
      for (let j = 0; j < attributes.length; j++) {
        if (i !== j) {
          const front = attributes[i];
          const back = attributes[j];
          const cardUniqueId = (recordId << 16) + pairIndex;
          results.push({ id: cardUniqueId, front, back });
          pairIndex++;
        }
      }
    }
    return results;
  }

  /**
   * If we were given ?cardId=...&side=(front|back), fetch that record from the DB,
   * reconstruct the permutations, and find the matching pair => load the requested side
   */
  async function loadCardFromDb(cardId, whichSide) {
    // recordId = top 16 bits
    const recordId = cardId >>> 16;
    // pairIndex = lower 16 bits (not strictly needed here, but for clarity)
    // const pairIndex = cardId & 0xFFFF;

    // get the record from DB
    const recordData = await getRecordById(recordId);
    if (!recordData) {
      console.error(`No record found in DB with id=${recordId}`);
      return "";
    }

    // build permutations
    const perms = generatePermutationsForRecord(recordId, recordData.text);
    // find the one with cardId
    const matching = perms.find(p => p.id === cardId);
    if (!matching) {
      console.error(`No matching cardId=${cardId} in record #${recordId}`);
      return "";
    }

    return (whichSide === "front") ? matching.front : matching.back;
  }

  /**
   * Simple helper to get a single record by ID from the DB.
   */
  function getRecordById(recordId) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const store = tx.objectStore(STORE_NAME);
      const getReq = store.get(recordId);
      getReq.onsuccess = e => {
        resolve(e.target.result); // either undefined or {id, text}
      };
      getReq.onerror = err => {
        reject(err);
      };
    });
  }

  /********************************************************************
   *   Sentence Reconstruction Logic
   ********************************************************************/
  const initialView = document.getElementById("initialView");
  const gameView = document.getElementById("gameView");
  const startBtn = document.getElementById("startBtn");
  const clearBtn = document.getElementById("clearBtn");
  const userInput = document.getElementById("userInput");

  const progressText = document.getElementById("progressText");
  const workInProgress = document.getElementById("workInProgress");
  const completionMsg = document.getElementById("completionMsg");

  const restartBtn = document.getElementById("restartBtn");
  const clearBtn2 = document.getElementById("clearBtn2");

  // Common “filler” words to skip
  const skipWordsSet = new Set([
    'a','an','the','is','are','and','or','but','nor','yet','so','for','of','in','to','by','with','from',
    'it','its','be','am','was','were','this','that','these','those','at','on','if','do','does','did',
    'because','since','i','me','my','you','your','he','she','they','them','we','us','as','then','out',
    'up','down','over','under','above','below','have','has','had','can','may','should','would','could',
    'go','goes','went','just','now','will','shall','very','every','all','what','when','where','how','why'
  ]);

  let tokenData = [];
  let guessableTokens = [];
  let currentGuessIndex = 0;
  let sanitizedText = '';

  window.addEventListener("load", async () => {
    // 1) open the DB
    await openDatabase();

    // 2) check if we have cardId & side
    const rawCardId = getUrlParameter("cardId").trim();
    const rawSide = getUrlParameter("side").trim().toLowerCase();

    // If we do, load the text from DB and start the game automatically
    if (rawCardId && rawSide && (rawSide === "front" || rawSide === "back")) {
      const cardIdNum = parseInt(rawCardId, 10);
      if (Number.isNaN(cardIdNum)) {
        console.warn("Invalid cardId param:", rawCardId);
        return;
      }
      const textFromDb = await loadCardFromDb(cardIdNum, rawSide);
      if (textFromDb) {
        // We have the single attribute from the DB. Let's do the game.
        startGame(textFromDb);
      }
    }
  });

  /**
   * If the user manually clicks "Start", we take the entire userInput, store it, then start the game.
   */
  startBtn.addEventListener("click", async () => {
    let rawInputVal = userInput.value.trim();
    if (!rawInputVal) {
      alert("Please enter some text first!");
      return;
    }

    // Insert into DB with date/time prefix, replacing commas with underscores
    const now = new Date();
    const yy = String(now.getFullYear()).slice(-2);
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    const hh = String(now.getHours()).padStart(2, '0');
    const min = String(now.getMinutes()).padStart(2, '0');
    const ss = String(now.getSeconds()).padStart(2, '0');
    const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;

    let inputNoCommas = rawInputVal.replace(/,/g, "_");
    const fullLine = `${datePrefix}, ${inputNoCommas}`;
    await addLinesToDb([fullLine]);

    // Then run the game with the typed text
    startGame(inputNoCommas);
  });

  /**
   * The main function to parse + set up the reconstruction from an input text
   */
  function startGame(inputText) {
    // 1) sanitize
    sanitizedText = sanitizeText(inputText);
    // 2) split tokens
    const rawTokens = sanitizedText.split(/\s+/);

    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    // Build token data
    rawTokens.forEach(tok => {
      const cleaned = cleanWord(tok);
      let skip = false;
      if (!cleaned || skipWordsSet.has(cleaned)) {
        skip = true;
      }
      tokenData.push({
        original: tok,
        cleaned: cleaned,
        skip: skip,
        guessed: skip // skip-words are effectively "already guessed"
      });
    });

    // Fill guessableTokens
    tokenData.forEach((t, idx) => {
      if (!t.skip) {
        guessableTokens.push(idx);
      }
    });

    // Switch UI
    initialView.classList.add('d-none');
    gameView.classList.remove('d-none');

    updateDisplayedText();
  }

  // Clear all - reset page
  function clearAllPage() {
    userInput.value = '';
    sanitizedText = '';
    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    workInProgress.innerHTML = '';
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    initialView.classList.remove('d-none');
    gameView.classList.add('d-none');
  }
  clearBtn.addEventListener('click', clearAllPage);
  clearBtn2.addEventListener('click', clearAllPage);

  // Restart game with the same sanitized text
  restartBtn.addEventListener('click', () => {
    if (!sanitizedText) return;
    tokenData.forEach(t => {
      if (!t.skip) t.guessed = false;
    });
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';
    updateDisplayedText();
  });

  /*********************************************
   * Utility functions for the reconstruction
   *********************************************/
  /**
   * sanitizeText:
   * - Replaces " with __
   * - Replaces ? with _q
   * - Replaces ! with _x
   * - Replaces other punctuation => _
   * - Lowercase, remove multiple spaces
   */
  function sanitizeText(input) {
    let text = input;
    text = text.replace(/"/g, ' __ ');
    text = text.replace(/\?/g, ' _q ');
    text = text.replace(/!/g, ' _x ');
    text = text.replace(/[^a-zA-Z0-9\s_]/g, ' _ ');
    text = text.toLowerCase();
    text = text.replace(/\s+/g, ' ').trim();
    return text;
  }

  function cleanWord(word) {
    // Remove leading/trailing underscores
    return word.replace(/^_+|_+$/g, '');
  }

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(getSecureRandomNumber() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  /**
   * Build array of 4 unique choices: the correct word + 3 distinct wrong words
   */
  function getChoicesForCurrentToken() {
    if (currentGuessIndex >= guessableTokens.length) {
      return [];
    }
    const correctIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctIndex].cleaned;

    const pool = guessableTokens
      .filter(i => i !== correctIndex)
      .map(i => tokenData[i].cleaned);

    const uniquePool = Array.from(new Set(pool));
    shuffleArray(uniquePool);

    // take 3
    const wrongChoices = uniquePool.slice(0, 3);
    const allChoices = [correctClean, ...wrongChoices];
    shuffleArray(allChoices);

    return allChoices;
  }

  /**
   * Returns a greenish hex color based on progress
   */
  function getProgressColor(percentage) {
    if (percentage <= 0) {
      return '#FFFFFF';
    } else if (percentage < 25) {
      return '#edf8e1';
    } else if (percentage < 50) {
      return '#bae4b3';
    } else if (percentage < 75) {
      return '#74c476';
    } else if (percentage < 100) {
      return '#31a354';
    } else {
      return '#006d2c';
    }
  }

  /**
   * Build the HTML for the entire puzzle (tokens, choice buttons, underscores).
   */
  function buildSentenceHTML() {
    let html = '';
    const choices = getChoicesForCurrentToken();

    let progressPercent = 0;
    if (guessableTokens.length > 0) {
      progressPercent = (currentGuessIndex / guessableTokens.length) * 100;
    }
    const progressPercentFixed = progressPercent.toFixed(1);
    const buttonColor = getProgressColor(progressPercent);

    for (let i = 0; i < tokenData.length; i++) {
      const t = tokenData[i];
      if (t.skip || t.guessed) {
        // show token as-is
        html += `<span class="me-1">${t.original}</span>`;
      } else {
        const thisIsCurrent = (guessableTokens[currentGuessIndex] === i);
        if (thisIsCurrent) {
          // show underscores + choice buttons
          const underscores = '_'.repeat(t.cleaned.length || 4);

          let buttonsHTML = '';
          choices.forEach(choice => {
            buttonsHTML += `
              <button
                class="btn me-2 mb-1"
                style="display:inline-block; background-color: ${buttonColor}; color: #000;"
                onclick="handleChoiceClick('${choice}')"
              >
                ${choice}
              </button>
            `;
          });

          // 5th disabled button for progress
          buttonsHTML += `
            <button
              class="btn mb-1"
              style="display:inline-block; background-color: ${buttonColor}; color: #000;"
              disabled
            >
              ${progressPercentFixed}%
            </button>
          `;

          html += `
            <span class="me-1" style="white-space: nowrap;">
              ${underscores}
              <span class="choice-buttons-inline">
                ${buttonsHTML}
              </span>
            </span>
          `;
        } else {
          // not the current token
          const underscores = '_'.repeat(t.cleaned.length || 4);
          html += `<span class="me-1">${underscores}</span>`;
        }
      }
    }
    return html;
  }

  function updateDisplayedText() {
    workInProgress.innerHTML = buildSentenceHTML();
  }

  function handleChoiceClick(chosenWord) {
    if (currentGuessIndex >= guessableTokens.length) {
      return;
    }
    const correctTokenIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctTokenIndex].cleaned;

    if (chosenWord === correctClean) {
      tokenData[correctTokenIndex].guessed = true;
      currentGuessIndex++;
      if (currentGuessIndex === guessableTokens.length) {
        completionMsg.textContent = "You have successfully reconstructed the text!";
        completionMsg.classList.remove('d-none');
      }
    }
    updateDisplayedText();
  }
  // Expose to the global scope so inline onclick works
  window.handleChoiceClick = handleChoiceClick;

  /********************************************************************
   * NEW FUNCTIONS FOR EXTRA TOOLS (ALWAYS VISIBLE)
   ********************************************************************/

  /**
   * Open ChatGPT with the current text area contents in a new tab
   */
  function searchChatGPT() {
    const textVal = userInput.value.trim();
    if (!textVal) {
      alert("No text found in the textarea to search!");
      return;
    }
    const encoded = encodeURIComponent(textVal);
    const url = `https://chat.openai.com/?q=${encoded}`;
    window.open(url, "_blank");
  }

  /**
   * Summarize the user input. (Placeholder logic – adapt as needed.)
   */
  function summarizeText() {
    const textVal = userInput.value.trim();
    if (!textVal) {
      alert("No text found to summarize!");
      return;
    }
    // In a real scenario, you'd do something more advanced or call an API.
    // Here, we'll just show a quick approximation or placeholder:
    alert("Summary:\n\nThis is a very rough placeholder summary.\n(Implement an AI or custom logic to do real summarization.)");
  }

  /**
   * Generate a quick quiz from the user input. (Placeholder logic.)
   */
  function generateQuiz() {
    const textVal = userInput.value.trim();
    if (!textVal) {
      alert("No text found to generate a quiz!");
      return;
    }
    // Just an example:
    alert("Quiz generated (placeholder):\n1) What is the main topic?\n2) List one key detail.\n(Implement real quiz logic here.)");
  }

  /**
   * Use speech synthesis to read aloud the user input
   */
  function readAloudText() {
    const textVal = userInput.value.trim();
    if (!textVal) {
      alert("No text to read aloud!");
      return;
    }
    const utter = new SpeechSynthesisUtterance(textVal);
    speechSynthesis.speak(utter);
  }

  /**
   * Highlight "keywords" in the input – naive approach
   */
  function highlightKeywords() {
    const textVal = userInput.value.trim();
    if (!textVal) {
      alert("No text found to highlight!");
      return;
    }
    // For demonstration: we highlight any word with length >= 7
    const highlighted = textVal.split(/\s+/).map(word => {
      if (word.length >= 7) {
        return `**${word}**`;
      }
      return word;
    }).join(" ");

    alert("Highlighted words (7+ letters) in the text:\n\n" + highlighted + "\n\n(Replace with actual text rendering, if desired.)");
  }
</script>
</body>
</html>
