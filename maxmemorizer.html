<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Sentence Reconstruction Game</title>
  <!-- Bootstrap CSS (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <style>
    /* Ensure the reconstruction area is of modest size initially but can grow. */
    #workInProgress {
      width: 100%;
      min-height: 150px; /* modest initial height */
      overflow-wrap: break-word; /* handle long text gracefully */
    }

    /* Make sure choice buttons + progress appear inline for the current guess */
    .choice-buttons-inline {
      margin-left: 8px;
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
    }
  </style>
</head>
<body class="bg-light">

<div class="container my-5">
  <h1 class="text-center mb-4">Sentence Reconstruction</h1>

  <!-- Text Area and Control Buttons (Initial View) -->
  <div id="initialView">
    <div class="mb-3">
      <label for="userInput" class="form-label fw-bold">Enter Your Passage:</label>
      <textarea
        class="form-control"
        id="userInput"
        rows="6"
        placeholder="Type or paste your paragraphs here..."
      ></textarea>
    </div>
    <button id="startBtn" class="btn btn-primary me-2">Start</button>
    <button id="clearBtn" class="btn btn-secondary">Clear All</button>
  </div>

  <!-- Game View (Hidden by Default) -->
  <div id="gameView" class="d-none">
    <p class="fw-bold" id="progressText">
      Reconstructing your text ...
    </p>
    <div class="mb-3">
      <!-- This is where the reconstructed text (plus choices inline) will appear -->
      <div id="workInProgress" class="p-3 border"></div>
    </div>

    <!-- Informational Feedback -->
    <div class="alert alert-info d-none" id="completionMsg"></div>

    <!-- Game Control Buttons -->
    <button id="restartBtn" class="btn btn-warning me-2">Restart</button>
    <button id="clearBtn2" class="btn btn-secondary">Clear All</button>
  </div>
</div>

<!-- Bootstrap Bundle JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /**************************************************
   *   Shared IndexedDB Setup
   *   Using the same DB_NAME, STORE_NAME
   **************************************************/
  const DB_NAME = "myCsvDb_default"; // must match Land Cruiser 300 page
  const DB_VERSION = 1;
  const STORE_NAME = "records";
  let db = null;

  /**
   * Opens (or creates/upgrades) the shared IndexedDB database.
   */
  function openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onupgradeneeded = (event) => {
        db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, {
            keyPath: 'id',
            autoIncrement: true
          });
          store.createIndex('textIndex', 'text', { unique: true });
        }
      };
      request.onsuccess = (event) => {
        db = event.target.result;
        resolve(db);
      };
      request.onerror = (event) => {
        console.error("IndexedDB error:", event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * Insert lines into DB, skipping duplicates.
   */
  function addLinesToDb(lines) {
    return new Promise((resolve, reject) => {
      if (!db) {
        console.error("IndexedDB is not opened yet!");
        resolve(0);
        return;
      }
      let addedCount = 0;
      const tx = db.transaction(STORE_NAME, "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const textIndex = store.index("textIndex");

      let processedCount = 0;

      function processNext(i) {
        if (i >= lines.length) {
          resolve(addedCount);
          return;
        }
        const line = lines[i].trim();
        if (!line) {
          processedCount++;
          processNext(i + 1);
          return;
        }
        const checkReq = textIndex.get(line);
        checkReq.onsuccess = () => {
          if (checkReq.result) {
            // Duplicate found, skip
            processedCount++;
            processNext(i + 1);
          } else {
            const addReq = store.add({ text: line });
            addReq.onsuccess = () => {
              addedCount++;
              processedCount++;
              processNext(i + 1);
            };
            addReq.onerror = () => {
              processedCount++;
              processNext(i + 1);
            };
          }
        };
        checkReq.onerror = () => {
          processedCount++;
          processNext(i + 1);
        };
      }
      processNext(0);

      tx.oncomplete = () => {
        // done
      };
      tx.onerror = (err) => {
        console.error("Transaction error:", err);
        reject(err);
      };
    });
  }

  /**
   * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
   */
  function getSecureRandomNumber() {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0] / (0xFFFFFFFF + 1);
  }

  /**************************************************
   *   Sentence Reconstruction Logic
   **************************************************/
  const initialView = document.getElementById("initialView");
  const gameView = document.getElementById("gameView");
  const startBtn = document.getElementById("startBtn");
  const clearBtn = document.getElementById("clearBtn");
  const userInput = document.getElementById("userInput");

  const progressText = document.getElementById("progressText");
  const workInProgress = document.getElementById("workInProgress");
  const completionMsg = document.getElementById("completionMsg");

  const restartBtn = document.getElementById("restartBtn");
  const clearBtn2 = document.getElementById("clearBtn2");

  // Expanded skip words set
  const skipWordsSet = new Set([
    'a','an','the','is','are','and','or','but','nor','yet','so','for','of','in','to','by','with','from',
    'it','its','be','am','was','were','this','that','these','those','at','on','if','do','does','did',
    'because','since','i','me','my','you','your','he','she','they','them','we','us','as','then','out',
    'up','down','over','under','above','below','have','has','had','can','may','should','would','could',
    'go','goes','went','just','now','will','shall','very','every','all','what','when','where','how','why'
  ]);

  // Array of token metadata
  let tokenData = [];
  // Indices of guessable tokens
  let guessableTokens = [];
  // Current index in guessableTokens
  let currentGuessIndex = 0;
  // We'll store sanitized text for re-init
  let sanitizedText = '';

  // Query param helper
  function getUrlParameter(name) {
    name = name.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(window.location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
  }

  // On load: open DB, see if we have startText param
  window.addEventListener('load', async () => {
    await openDatabase();
    // Check if ?startText= is present
    const passedText = getUrlParameter('startText').trim();
    if (passedText) {
      // Insert it into DB (like "Add Text to DB")
      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const min = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;

      const textNoCommas = passedText.replace(/,/g, "_");
      const fullLine = `${datePrefix}, ${textNoCommas}`;
      await addLinesToDb([fullLine]);

      // Now automatically start the game with that text
      startGame(textNoCommas);
    }
  });

  /**
   * If user manually clicks Start:
   * 1) Insert text into DB (like Add Text to DB)
   * 2) Then run game logic
   */
  startBtn.addEventListener('click', async () => {
    let rawInputVal = userInput.value.trim();
    if (!rawInputVal) {
      alert("Please enter some text first!");
      return;
    }

    // Insert into DB
    const now = new Date();
    const yy = String(now.getFullYear()).slice(-2);
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    const hh = String(now.getHours()).padStart(2, '0');
    const min = String(now.getMinutes()).padStart(2, '0');
    const ss = String(now.getSeconds()).padStart(2, '0');
    const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;

    let inputNoCommas = rawInputVal.replace(/,/g, "_");
    const fullLine = `${datePrefix}, ${inputNoCommas}`;
    await addLinesToDb([fullLine]);

    // Now run the game logic
    startGame(inputNoCommas);
  });

  // The main game logic in a function so we can call it from both param-based and Start button
  function startGame(inputText) {
    // 1) Sanitize
    sanitizedText = sanitizeText(inputText);
    // 2) Split
    const rawTokens = sanitizedText.split(/\s+/);

    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    // Build token data
    rawTokens.forEach(tok => {
      const cleaned = cleanWord(tok);
      let skip = false;
      if (!cleaned || skipWordsSet.has(cleaned)) {
        skip = true;
      }
      tokenData.push({
        original: tok,
        cleaned: cleaned,
        skip: skip,
        guessed: skip // skip-words are effectively guessed
      });
    });

    // Fill guessableTokens
    tokenData.forEach((t, idx) => {
      if (!t.skip) {
        guessableTokens.push(idx);
      }
    });

    // Switch UI
    initialView.classList.add('d-none');
    gameView.classList.remove('d-none');

    // Render
    updateDisplayedText();
  }

  // Clear All resets page state
  function clearAllPage() {
    userInput.value = '';
    sanitizedText = '';
    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    workInProgress.innerHTML = '';
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    initialView.classList.remove('d-none');
    gameView.classList.add('d-none');
  }
  clearBtn.addEventListener('click', clearAllPage);
  clearBtn2.addEventListener('click', clearAllPage);

  // Restart game with same sanitized text
  restartBtn.addEventListener('click', () => {
    if (!sanitizedText) return;
    tokenData.forEach(t => {
      if (!t.skip) t.guessed = false;
    });
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';
    updateDisplayedText();
  });

  /*********************************************
   * Utility functions
   *********************************************/
  /**
   * Sanitize text:
   * - Replace double quotes -> __
   * - Replace ? with _q
   * - Replace ! with _x
   * - Replace other punctuation => _
   * - Lowercase, remove multiple spaces
   */
  function sanitizeText(input) {
    let text = input;
    text = text.replace(/"/g, ' __ ');
    text = text.replace(/\?/g, ' _q ');
    text = text.replace(/!/g, ' _x ');
    text = text.replace(/[^a-zA-Z0-9\s_]/g, ' _ ');
    text = text.toLowerCase();
    text = text.replace(/\s+/g, ' ').trim();
    return text;
  }

  function cleanWord(word) {
    return word.replace(/^_+|_+$/g, '');
  }

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(getSecureRandomNumber() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Build array of 4 unique choices: correct + 3 distinct wrong
  function getChoicesForCurrentToken() {
    if (currentGuessIndex >= guessableTokens.length) {
      return [];
    }
    const correctIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctIndex].cleaned;

    const pool = guessableTokens
      .filter(i => i !== correctIndex)
      .map(i => tokenData[i].cleaned);

    const uniquePool = Array.from(new Set(pool));
    shuffleArray(uniquePool);

    const wrongChoices = uniquePool.slice(0, 3);

    let allChoices = [correctClean, ...wrongChoices];
    shuffleArray(allChoices);

    return allChoices;
  }

  // Progress-based color
  function getProgressColor(percentage) {
    if (percentage <= 0) {
      return '#FFFFFF';
    } else if (percentage < 25) {
      return '#edf8e1';
    } else if (percentage < 50) {
      return '#bae4b3';
    } else if (percentage < 75) {
      return '#74c476';
    } else if (percentage < 100) {
      return '#31a354';
    } else {
      return '#006d2c';
    }
  }

  function buildSentenceHTML() {
    let html = '';
    const choices = getChoicesForCurrentToken();

    let progressPercent = 0;
    if (guessableTokens.length > 0) {
      progressPercent = (currentGuessIndex / guessableTokens.length) * 100;
    }
    const progressPercentFixed = progressPercent.toFixed(1);
    const buttonColor = getProgressColor(progressPercent);

    for (let i = 0; i < tokenData.length; i++) {
      const t = tokenData[i];
      if (t.skip || t.guessed) {
        html += `<span class="me-1">${t.original}</span>`;
      } else {
        const thisIsCurrent = (guessableTokens[currentGuessIndex] === i);
        if (thisIsCurrent) {
          let underscores = '_'.repeat(t.cleaned.length || 4);

          let buttonsHTML = '';
          choices.forEach(choice => {
            buttonsHTML += `
              <button
                class="btn me-2 mb-1"
                style="display:inline-block; background-color: ${buttonColor}; color: #000;"
                onclick="handleChoiceClick('${choice}')"
              >
                ${choice}
              </button>
            `;
          });

          // add progress button
          buttonsHTML += `
            <button
              class="btn mb-1"
              style="display:inline-block; background-color: ${buttonColor}; color: #000;"
              disabled
            >
              ${progressPercentFixed}%
            </button>
          `;

          html += `
            <span class="me-1" style="white-space: nowrap;">
              ${underscores}
              <span class="choice-buttons-inline">
                ${buttonsHTML}
              </span>
            </span>
          `;
        } else {
          let underscores = '_'.repeat(t.cleaned.length || 4);
          html += `<span class="me-1">${underscores}</span>`;
        }
      }
    }
    return html;
  }

  function updateDisplayedText() {
    workInProgress.innerHTML = buildSentenceHTML();
  }

  function handleChoiceClick(chosenWord) {
    if (currentGuessIndex >= guessableTokens.length) return;
    const correctTokenIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctTokenIndex].cleaned;

    if (chosenWord === correctClean) {
      tokenData[correctTokenIndex].guessed = true;
      currentGuessIndex++;
      if (currentGuessIndex === guessableTokens.length) {
        completionMsg.textContent = "You have successfully reconstructed the text!";
        completionMsg.classList.remove('d-none');
      }
    }
    updateDisplayedText();
  }
  window.handleChoiceClick = handleChoiceClick;
</script>
</body>
</html>
