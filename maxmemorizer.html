<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Sentence Reconstruction Game</title>
  <!-- Bootstrap CSS (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <style>
    /* Ensure the reconstruction area is of modest size initially but can grow. */
    #workInProgress {
      width: 100%;
      min-height: 150px; /* modest initial height */
      overflow-wrap: break-word; /* handle long text gracefully */
    }

    /* Make sure choice buttons + progress appear inline for the current guess */
    .choice-buttons-inline {
      margin-left: 8px;
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
    }
  </style>
</head>
<body class="bg-light">

<div class="container my-5">
  <h1 class="text-center mb-4">Sentence Reconstruction</h1>

  <!-- Text Area and Control Buttons (Initial View) -->
  <div id="initialView">
    <div class="mb-3">
      <label for="userInput" class="form-label fw-bold">Enter Your Passage:</label>
      <textarea
        class="form-control"
        id="userInput"
        rows="6"
        placeholder="Type or paste your paragraphs here..."
      ></textarea>
    </div>
    <button id="startBtn" class="btn btn-primary me-2">Start</button>
    <button id="clearBtn" class="btn btn-secondary">Clear All</button>
  </div>

  <!-- Game View (Hidden by Default) -->
  <div id="gameView" class="d-none">
    <p class="fw-bold" id="progressText">
      Reconstructing your text ...
    </p>
    <div class="mb-3">
      <!-- This is where the reconstructed text (plus choices inline) will appear -->
      <div id="workInProgress" class="p-3 border"></div>
    </div>

    <!-- Informational Feedback -->
    <div class="alert alert-info d-none" id="completionMsg"></div>

    <!-- Game Control Buttons -->
    <button id="restartBtn" class="btn btn-warning me-2">Restart</button>
    <button id="clearBtn2" class="btn btn-secondary">Clear All</button>
  </div>
</div>

<!-- Bootstrap Bundle JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /***********************************************
   * IndexedDB Setup: same logic from your main code
   ***********************************************/
  const DB_NAME = 'myCsvDb_default';
  const DB_VERSION = 1;
  const STORE_NAME = 'records';
  let db = null;

  /**
   * Open (or create/upgrade) the IndexedDB database.
   */
  function openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onupgradeneeded = (event) => {
        db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, {
            keyPath: 'id',
            autoIncrement: true
          });
          store.createIndex('textIndex', 'text', { unique: true });
        }
      };
      request.onsuccess = (event) => {
        db = event.target.result;
        resolve(db);
      };
      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  /**
   * Adds the given lines to the DB, skipping duplicates (by checking textIndex).
   * @param {string[]} lines
   */
  function addLinesToDb(lines) {
    return new Promise((resolve, reject) => {
      if (!db) {
        console.error('IndexedDB not opened yet!');
        resolve(0);
        return;
      }
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const textIndex = store.index('textIndex');

      let addedCount = 0;
      let processedCount = 0;

      function processNextLine(i) {
        if (i >= lines.length) {
          resolve(addedCount);
          return;
        }
        const line = lines[i].trim();
        if (!line) {
          processedCount++;
          processNextLine(i + 1);
          return;
        }
        // Check if it's already in DB
        const checkReq = textIndex.get(line);
        checkReq.onsuccess = () => {
          if (checkReq.result) {
            // Duplicate found; skip adding
            processedCount++;
            processNextLine(i + 1);
          } else {
            // Add new record
            const addReq = store.add({ text: line });
            addReq.onsuccess = () => {
              addedCount++;
              processedCount++;
              processNextLine(i + 1);
            };
            addReq.onerror = () => {
              processedCount++;
              processNextLine(i + 1);
            };
          }
        };
        checkReq.onerror = () => {
          processedCount++;
          processNextLine(i + 1);
        };
      }
      processNextLine(0);

      tx.oncomplete = () => { /* transaction done */ };
      tx.onerror = (err) => {
        console.error('Transaction error:', err);
        reject(err);
      };
    });
  }

  /**
   * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
   */
  function getSecureRandomNumber() {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0] / (0xFFFFFFFF + 1);
  }

  /***********************************************
   * Sentence Reconstruction Logic
   ***********************************************/
  // Grab references to DOM elements
  const initialView = document.getElementById('initialView');
  const gameView = document.getElementById('gameView');
  const startBtn = document.getElementById('startBtn');
  const clearBtn = document.getElementById('clearBtn');
  const userInput = document.getElementById('userInput');

  const progressText = document.getElementById('progressText');
  const workInProgress = document.getElementById('workInProgress');
  const completionMsg = document.getElementById('completionMsg');

  const restartBtn = document.getElementById('restartBtn');
  const clearBtn2 = document.getElementById('clearBtn2');

  // Expanded skip words set
  const skipWordsSet = new Set([
    'a','an','the','is','are','and','or','but','nor','yet','so','for','of','in','to','by','with','from',
    'it','its','be','am','was','were','this','that','these','those','at','on','if','do','does','did',
    'because','since','i','me','my','you','your','he','she','they','them','we','us','as','then','out',
    'up','down','over','under','above','below','have','has','had','can','may','should','would','could',
    'go','goes','went','just','now','will','shall','very','every','all','what','when','where','how','why'
  ]);

  // We'll store metadata for each token
  let tokenData = [];
  // Indices for guessable tokens
  let guessableTokens = [];
  // Current index in guessableTokens
  let currentGuessIndex = 0;
  // We store sanitized text for re-init on "Restart"
  let sanitizedText = '';

  /**
   * Sanitize the text:
   *  - Replace double quotes -> " __ "
   *  - Replace question marks -> " _q "
   *  - Replace exclamation -> " _x "
   *  - Replace all other punctuation/special chars -> " _ "
   *  - convert to lowercase
   *  - remove multiple spaces
   */
  function sanitizeText(input) {
    let text = input;
    text = text.replace(/"/g, ' __ ');
    text = text.replace(/\?/g, ' _q ');
    text = text.replace(/!/g, ' _x ');
    text = text.replace(/[^a-zA-Z0-9\s_]/g, ' _ ');
    text = text.toLowerCase();
    text = text.replace(/\s+/g, ' ').trim();
    return text;
  }

  // Helper to strip underscores from edges
  function cleanWord(word) {
    return word.replace(/^_+|_+$/g, '');
  }

  // Shuffle array with cryptographically secure random
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(getSecureRandomNumber() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Build array of four unique choices
  function getChoicesForCurrentToken() {
    if (currentGuessIndex >= guessableTokens.length) {
      return [];
    }
    const correctIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctIndex].cleaned;

    // All other guessable words
    const pool = guessableTokens
      .filter(i => i !== correctIndex)
      .map(i => tokenData[i].cleaned);

    const uniquePool = Array.from(new Set(pool));
    shuffleArray(uniquePool);

    // Take first 3
    const wrongChoices = uniquePool.slice(0, 3);

    let allChoices = [correctClean, ...wrongChoices];
    shuffleArray(allChoices);

    return allChoices;
  }

  /**
   * Returns a greenish hex color based on progress (0-100).
   */
  function getProgressColor(percentage) {
    if (percentage <= 0) {
      return '#FFFFFF'; /* White */
    } else if (percentage < 25) {
      return '#edf8e1'; /* Very light green */
    } else if (percentage < 50) {
      return '#bae4b3'; /* Light green */
    } else if (percentage < 75) {
      return '#74c476'; /* Greenish */
    } else if (percentage < 100) {
      return '#31a354'; /* More intense green */
    } else {
      return '#006d2c'; /* Deep green at 100% */
    }
  }

  // Build the reconstruction HTML
  function buildSentenceHTML() {
    let html = '';
    const choices = getChoicesForCurrentToken();

    let progressPercent = 0;
    if (guessableTokens.length > 0) {
      progressPercent = (currentGuessIndex / guessableTokens.length) * 100;
    }
    const progressPercentFixed = progressPercent.toFixed(1);
    const buttonColor = getProgressColor(progressPercent);

    for (let i = 0; i < tokenData.length; i++) {
      const t = tokenData[i];
      if (t.skip || t.guessed) {
        // Display token as-is
        html += `<span class="me-1">${t.original}</span>`;
      } else {
        const thisIsCurrent = (guessableTokens[currentGuessIndex] === i);
        if (thisIsCurrent) {
          // Show underscores + choice buttons
          let underscores = '_'.repeat(t.cleaned.length || 4);

          let buttonsHTML = '';
          choices.forEach(choice => {
            buttonsHTML += `
              <button
                class="btn me-2 mb-1"
                style="display:inline-block; background-color: ${buttonColor}; color: #000;"
                onclick="handleChoiceClick('${choice}')"
              >
                ${choice}
              </button>
            `;
          });

          // 5th disabled button for progress
          buttonsHTML += `
            <button
              class="btn mb-1"
              style="display:inline-block; background-color: ${buttonColor}; color: #000;"
              disabled
            >
              ${progressPercentFixed}%
            </button>
          `;

          html += `
            <span class="me-1" style="white-space: nowrap;">
              ${underscores}
              <span class="choice-buttons-inline">
                ${buttonsHTML}
              </span>
            </span>
          `;
        } else {
          // It's guessable but not current
          let underscores = '_'.repeat(t.cleaned.length || 4);
          html += `<span class="me-1">${underscores}</span>`;
        }
      }
    }
    return html;
  }

  function updateDisplayedText() {
    workInProgress.innerHTML = buildSentenceHTML();
  }

  // Handle choice clicks
  function handleChoiceClick(chosenWord) {
    if (currentGuessIndex >= guessableTokens.length) {
      return;
    }
    const correctTokenIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctTokenIndex].cleaned;

    if (chosenWord === correctClean) {
      tokenData[correctTokenIndex].guessed = true;
      currentGuessIndex++;
      if (currentGuessIndex === guessableTokens.length) {
        completionMsg.textContent = 'You have successfully reconstructed the text!';
        completionMsg.classList.remove('d-none');
      }
    }
    updateDisplayedText();
  }
  window.handleChoiceClick = handleChoiceClick; // expose globally

  // Clear all - reset page
  function clearAllPage() {
    userInput.value = '';
    sanitizedText = '';
    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    workInProgress.innerHTML = '';
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    initialView.classList.remove('d-none');
    gameView.classList.add('d-none');
  }
  clearBtn.addEventListener('click', clearAllPage);
  clearBtn2.addEventListener('click', clearAllPage);

  // Start the game + log input to IndexedDB
  startBtn.addEventListener('click', async () => {
    let rawInput = userInput.value.trim();
    if (!rawInput) {
      alert('Please enter some text first!');
      return;
    }

    /****************************************
     * 1) Write the user's text into IndexedDB
     *    (similar to "Add Text to DB" logic)
     ****************************************/
    await openDatabase();

    // Replace commas with underscores
    rawInput = rawInput.replace(/,/g, '_');

    // Build date-time prefix => "YYMMDD hh:mm:ss"
    const now = new Date();
    const yy = String(now.getFullYear()).slice(-2);
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    const hh = String(now.getHours()).padStart(2, '0');
    const min = String(now.getMinutes()).padStart(2, '0');
    const ss = String(now.getSeconds()).padStart(2, '0');
    const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;

    const fullLine = `${datePrefix}, ${rawInput}`;
    try {
      const insertedCount = await addLinesToDb([fullLine]);
      console.log(`Inserted ${insertedCount} line(s) into IndexedDB.`);
    } catch (err) {
      console.error('Error inserting line into DB:', err);
    }

    /****************************************
     * 2) Proceed with the sentence game logic
     ****************************************/
    // Now sanitize and set up the reconstruction game
    sanitizedText = sanitizeText(rawInput);
    const rawTokens = sanitizedText.split(/\s+/);

    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    rawTokens.forEach(tok => {
      const cleaned = cleanWord(tok);
      let skip = false;
      if (!cleaned || skipWordsSet.has(cleaned)) {
        skip = true;
      }
      tokenData.push({
        original: tok,
        cleaned: cleaned,
        skip: skip,
        guessed: skip // skip-words are effectively guessed
      });
    });

    // Indices for tokens that need guessing
    tokenData.forEach((t, idx) => {
      if (!t.skip) {
        guessableTokens.push(idx);
      }
    });

    // Switch UI to game mode
    initialView.classList.add('d-none');
    gameView.classList.remove('d-none');

    updateDisplayedText();
  });

  // Restart game (same sanitized text)
  restartBtn.addEventListener('click', () => {
    if (!sanitizedText) return;
    tokenData.forEach(t => {
      if (!t.skip) t.guessed = false;
    });
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';
    updateDisplayedText();
  });
</script>
</body>
</html>
