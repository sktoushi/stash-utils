<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Sentence Reconstruction Game</title>
  <!-- Bootstrap CSS (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <style>
    /* Ensure the reconstruction area is of modest size initially but can grow. */
    #workInProgress {
      width: 100%;
      min-height: 150px; /* modest initial height */
      overflow-wrap: break-word; /* handle long text gracefully */
    }

    /* Make sure choice buttons + progress appear inline for the current guess */
    .choice-buttons-inline {
      margin-left: 8px; 
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
    }
  </style>
</head>
<body class="bg-light">

<div class="container my-5">
  <h1 class="text-center mb-4">Sentence Reconstruction</h1>

  <!-- Text Area and Control Buttons (Initial View) -->
  <div id="initialView">
    <div class="mb-3">
      <label for="userInput" class="form-label fw-bold">Enter Your Passage:</label>
      <textarea
        class="form-control"
        id="userInput"
        rows="6"
        placeholder="Type or paste your paragraphs here..."
      ></textarea>
    </div>
    <button id="startBtn" class="btn btn-primary me-2">Start</button>
    <button id="clearBtn" class="btn btn-secondary">Clear All</button>
  </div>

  <!-- Game View (Hidden by Default) -->
  <div id="gameView" class="d-none">
    <p class="fw-bold" id="progressText">
      Reconstructing your text ...
    </p>
    <div class="mb-3">
      <!-- This is where the reconstructed text (plus choices inline) will appear -->
      <div id="workInProgress" class="p-3 border"></div>
    </div>

    <!-- Informational Feedback -->
    <div class="alert alert-info d-none" id="completionMsg"></div>

    <!-- Game Control Buttons -->
    <button id="restartBtn" class="btn btn-warning me-2">Restart</button>
    <button id="clearBtn2" class="btn btn-secondary">Clear All</button>
  </div>
</div>

<!-- Bootstrap Bundle JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /**
   * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
   */
  function getSecureRandomNumber() {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0] / (0xFFFFFFFF + 1);
  }

  // Grab references to DOM elements
  const initialView = document.getElementById('initialView');
  const gameView = document.getElementById('gameView');
  const startBtn = document.getElementById('startBtn');
  const clearBtn = document.getElementById('clearBtn');
  const userInput = document.getElementById('userInput');

  const progressText = document.getElementById('progressText');
  const workInProgress = document.getElementById('workInProgress');
  const completionMsg = document.getElementById('completionMsg');

  const restartBtn = document.getElementById('restartBtn');
  const clearBtn2 = document.getElementById('clearBtn2');

  // Skip words (articles, short words, etc.) that should be auto-guessed
  // You can add/remove from here as needed.
  const skipWordsSet = new Set([
    'a', 'an', 'the', 'is', 'are', 'and', 'or', 'but', 'nor', 'yet', 'so', 'for',
    'of', 'in', 'to', 'by', 'with', 'from'
  ]);

  // We'll store metadata for each token in the input.
  // tokenData[i] = { original: string, cleaned: string, skip: boolean, guessed: boolean }
  let tokenData = [];

  // guessableTokens is an array of indices pointing into tokenData for those tokens that must be guessed
  let guessableTokens = [];

  // The current index within guessableTokens that the user is trying to guess
  let currentGuessIndex = 0;

  // We'll store the sanitized-lowercased text so we can re-init if needed
  let sanitizedText = '';

  /**
   * Sanitize the text:
   * - Replace double quotes -> " __ "
   * - Replace question marks -> " _q "
   * - Replace exclamation -> " _x "
   * - Replace all other punctuation/special chars -> " _ "
   * - Then convert to lowercase
   * - Replace multiple spaces with single space
   * - Trim
   */
  function sanitizeText(input) {
    let text = input;

    // Replace double quotes with " __ " 
    text = text.replace(/"/g, ' __ ');

    // Replace question marks with " _q "
    text = text.replace(/\?/g, ' _q ');

    // Replace exclamation marks with " _x "
    text = text.replace(/!/g, ' _x ');

    // Replace everything else that's not alphanumeric or whitespace or underscores
    // or our special placeholders (_q, _x, __) with " _ "
    // We'll do a broad pattern, but skip letters, digits, whitespace, underscore
    // plus skip any leftover of the above sequences
    // We'll do multiple passes: first, any leftover punctuation is turned into " _ "
    // (including single quotes, apostrophes, commas, etc.)
    text = text.replace(/[^a-zA-Z0-9\s_]/g, ' _ ');

    // Now convert to lowercase
    text = text.toLowerCase();

    // Collapse multiple spaces 
    text = text.replace(/\s+/g, ' ').trim();

    return text;
  }

  // HELPER to remove leading/trailing underscores/spaces from a token, if any
  // Example: "___hello__" => "hello"
  // We'll just strip underscores from the edges; if token is entirely underscores, it becomes empty
  function cleanWord(word) {
    return word.replace(/^_+|_+$/g, '');
  }

  // Shuffle array with cryptographically secure random
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(getSecureRandomNumber() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Build an array of four unique choices: the correct word, plus 3 distinct "wrong" words
  function getChoicesForCurrentToken() {
    if (currentGuessIndex >= guessableTokens.length) {
      return [];
    }

    const correctIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctIndex].cleaned;

    // Build a pool of all other guessable words (cleaned)
    const pool = guessableTokens
      .filter(i => i !== correctIndex)
      .map(i => tokenData[i].cleaned);

    // remove duplicates from the pool if any
    const uniquePool = Array.from(new Set(pool));
    shuffleArray(uniquePool);

    // Take first 3
    const wrongChoices = uniquePool.slice(0, 3);

    // Combine correct + wrong, shuffle again
    let allChoices = [correctClean, ...wrongChoices];
    shuffleArray(allChoices);

    return allChoices;
  }

  // Return a string with the entire sanitized paragraph, including underscores for unguessed tokens,
  // plus the 4 choice buttons and progress inline for the current guess.
  function buildSentenceHTML() {
    let html = '';

    // We'll figure out the 4 choices for the current token (if needed)
    const choices = getChoicesForCurrentToken();

    // Calculate progress if we have guessable tokens
    let progressPercent = '0.0';
    if (guessableTokens.length > 0) {
      progressPercent = ((currentGuessIndex / guessableTokens.length) * 100).toFixed(1);
    }

    for (let i = 0; i < tokenData.length; i++) {
      const t = tokenData[i];
      // If skip or guessed, display the token as-is
      if (t.skip || t.guessed) {
        html += `<span class="me-1">${t.original}</span>`;
      } else {
        // Not guessed yet. Check if this is the current token to guess
        const thisIsCurrent = (guessableTokens[currentGuessIndex] === i);

        if (thisIsCurrent) {
          // We'll show underscores for the length
          let underscores = '_'.repeat(t.cleaned.length || 4);

          // Build the inline choice buttons + progress (the user wants them to the right).
          let buttonsHTML = '';
          choices.forEach(choice => {
            buttonsHTML += `<button 
              class="btn btn-outline-dark me-2 mb-1" 
              style="display:inline-block;"
              onclick="handleChoiceClick('${choice}')"
            >${choice}</button>`;
          });

          // The user wants a 5th disabled button showing progress
          buttonsHTML += `<button
              class="btn btn-secondary mb-1"
              style="display:inline-block;"
              disabled
            >
            ${progressPercent}%
            </button>`;

          html += `
            <span class="me-1" style="white-space: nowrap;">
              ${underscores}
              <span class="choice-buttons-inline">
                ${buttonsHTML}
              </span>
            </span>
          `;
        } else {
          // It's guessable but not the current token. Just show underscores
          let underscores = '_'.repeat(t.cleaned.length || 4);
          html += `<span class="me-1">${underscores}</span>`;
        }
      }
    }
    return html;
  }

  // Update the displayed text in #workInProgress
  function updateDisplayedText() {
    workInProgress.innerHTML = buildSentenceHTML();
  }

  // When the user clicks on one of the choice buttons
  function handleChoiceClick(chosenWord) {
    if (currentGuessIndex >= guessableTokens.length) {
      return;
    }

    const correctTokenIndex = guessableTokens[currentGuessIndex];
    const correctClean = tokenData[correctTokenIndex].cleaned;

    if (chosenWord === correctClean) {
      // Mark the token as guessed
      tokenData[correctTokenIndex].guessed = true;
      currentGuessIndex++;

      // Check if we've completed all guessable tokens
      if (currentGuessIndex === guessableTokens.length) {
        // Show final result
        completionMsg.textContent = 'You have successfully reconstructed the text!';
        completionMsg.classList.remove('d-none');
      }
    } 
    // If wrong, do nothing except re-render (choices re-shuffle)
    updateDisplayedText();
  }

  // Start the game
  startBtn.addEventListener('click', () => {
    let rawInput = userInput.value.trim();
    if (!rawInput) {
      alert('Please enter some text first!');
      return;
    }

    // 1) Sanitize text
    sanitizedText = sanitizeText(rawInput);

    // 2) Split by whitespace
    const rawTokens = sanitizedText.split(/\s+/);

    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    // Build token data
    rawTokens.forEach(tok => {
      // Clean leading/trailing underscores
      const cleaned = cleanWord(tok);

      // If after cleaning it's empty or skipWordsSet, we mark it skip
      let skip = false;
      if (!cleaned || skipWordsSet.has(cleaned)) {
        skip = true;
      }

      tokenData.push({
        original: tok,    // the sanitized raw token (with underscores replaced, etc.)
        cleaned: cleaned, // the final "core" portion for guessing
        skip: skip,
        guessed: skip     // skip-words are effectively "already guessed"
      });
    });

    // Fill guessableTokens from those not skip
    tokenData.forEach((t, idx) => {
      if (!t.skip) {
        guessableTokens.push(idx);
      }
    });

    // Hide initial view, show game view
    initialView.classList.add('d-none');
    gameView.classList.remove('d-none');

    // Initial render
    updateDisplayedText();
  });

  // Restart the game (same sanitized text in memory)
  restartBtn.addEventListener('click', () => {
    if (!sanitizedText) return;

    // Reset guess state
    tokenData.forEach((t) => {
      // skip tokens remain guessed
      if (!t.skip) t.guessed = false;
    });
    currentGuessIndex = 0;
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    updateDisplayedText();
  });

  // Clear all - reset the entire page to initial state
  function clearAllPage() {
    userInput.value = '';
    sanitizedText = '';
    tokenData = [];
    guessableTokens = [];
    currentGuessIndex = 0;
    workInProgress.innerHTML = '';
    completionMsg.classList.add('d-none');
    completionMsg.textContent = '';

    initialView.classList.remove('d-none');
    gameView.classList.add('d-none');
  }

  clearBtn.addEventListener('click', clearAllPage);
  clearBtn2.addEventListener('click', clearAllPage);

  // Expose handleChoiceClick globally so inline onclick works
  window.handleChoiceClick = handleChoiceClick;
</script>
</body>
</html>
