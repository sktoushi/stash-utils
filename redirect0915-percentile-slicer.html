<html>
<head>
    <title>Redirecting...</title>
    <script type="text/javascript">
        (function(){
            function updateCounter() {
            const UPDATE_VISITOR_API = "https://script.google.com/macros/s/AKfycbx-c7HUH9OnQBMwDAss1WpMV0uZAs8zHwGEHSn9EIQ_hTRBKVYLiPStXQTkbhfpcS7T/exec"; // 20240819_1530
            fetch(UPDATE_VISITOR_API, { mode: 'no-cors' })
                .then(response => {
                // Since we can't read the response due to no-cors, you can handle it here if necessary
                console.log('Request completed');
                })
                .catch(error => console.error('Error:', error));
            }
            function getSecureRandomNumber() {
                const array = new Uint32Array(1);
                window.crypto.getRandomValues(array);
                return array[0] / (0xFFFFFFFF + 1);
            }

            // New hashing function that returns a unique four-digit number based on URL parameters
            function hashUrlParams(params) {
                const str = params.toString();
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0; // Convert to 32bit integer
                }
                hash = Math.abs(hash);
                // Ensure it's a four-digit number between 1000 and 9999
                return (hash % 9000) + 1000;
            }

            const params = new URLSearchParams(window.location.search);
            const username = params.get('username');
            const repository = params.get('repository');
            const startIndex = parseInt(params.get('startIndex'));
            const endIndex = parseInt(params.get('endIndex'));

            const startDateParam = params.get('startDate');
            const goalParam = params.get('goal');
            let percentileParam = params.get('percentile');

            let percentile;

            if (startDateParam && goalParam) {
                // Ignore the percentile parameter and calculate it based on dates
                const goal = parseInt(goalParam);
                if (isNaN(goal) || goal <= 0) {
                    alert('Invalid goal parameter.');
                    return;
                }

                // Parse startDate in 'yyyymmdd' format
                const year = parseInt(startDateParam.substring(0, 4));
                const month = parseInt(startDateParam.substring(4, 6)) - 1; // Months are 0-indexed
                const day = parseInt(startDateParam.substring(6, 8));

                const startDate = new Date(year, month, day);
                const currentDate = new Date();
                // Zero out the time part for accurate day difference
                startDate.setHours(0, 0, 0, 0);
                currentDate.setHours(0, 0, 0, 0);

                const timeDiff = currentDate - startDate; // Difference in milliseconds
                const daysSinceStart = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                if (daysSinceStart <= 0) {
                    percentile = 1;
                } else if (daysSinceStart >= goal) {
                    percentile = 100;
                } else {
                    percentile = ((daysSinceStart / goal) * 99) + 1; // From 1% to 100%
                }
            } else {
                if (percentileParam === "random") {
                    percentile = Math.floor(getSecureRandomNumber() * 100) + 1; // Random percentile between 1 and 100
                } else {
                    percentile = parseFloat(percentileParam);
                }
            }

            if (!username || !repository || isNaN(startIndex) || isNaN(endIndex) || isNaN(percentile)) {
                alert('Missing or invalid parameters.');
                return;
            }

            percentile = Math.min(Math.max(percentile, 1), 100); // Ensure percentile is between 1 and 100

            const totalRange = endIndex - startIndex + 1; // Inclusive

            // New: Calculate hash result
            const hashResult = hashUrlParams(params);

            if (totalRange >= hashResult) {
                // Leave everything working the same way
                const percentileEnd = startIndex + Math.ceil(totalRange * (percentile / 100)) - 1;

                // Ensure percentileEnd is within the valid range
                const adjustedPercentileEnd = Math.min(Math.max(percentileEnd, startIndex), endIndex);

                const rangeSize = adjustedPercentileEnd - startIndex + 1;

                const randomNumber = Math.floor(getSecureRandomNumber() * rangeSize) + startIndex;
                updateCounter();
                const url = `https://github.com/${username}/${repository}/issues/${randomNumber}`;

                window.open(url, '_self');
            } else {
                // Artificially inflate the range
                const percentileEnd = startIndex + Math.ceil(totalRange * (percentile / 100)) - 1;
                const adjustedPercentileEnd = Math.min(Math.max(percentileEnd, startIndex), endIndex);
                const rangeSize = adjustedPercentileEnd - startIndex + 1;

                // Inflate the range to reach the hashResult as upper bound
                const inflatedRangeSize = hashResult;
                const inflatedRangeStart = startIndex;
                const inflatedRangeEnd = startIndex + inflatedRangeSize - 1;

                // Randomly pick from the inflated range
                const inflatedRandomIndex = Math.floor(getSecureRandomNumber() * inflatedRangeSize) + startIndex;

                // Map back to the original percentile range
                const mappedNumber = startIndex + ((inflatedRandomIndex - startIndex) % rangeSize);

                updateCounter();
                const url = `https://github.com/${username}/${repository}/issues/${mappedNumber}`;

                window.open(url, '_self');
            }
        })();
    </script>
</head>
<body>
    <p>Redirecting...</p>
</body>
</html>
