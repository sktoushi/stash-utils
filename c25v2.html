<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>c25 Tracker</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body class="bg-light p-4">
  <div class="container">
    <h1 class="mb-4">c25 Tracker</h1>

    <!-- Progress Bars -->
    <div id="progressContainer"></div>

    <!-- Aggregate projections -->
    <div id="aggregate" class="alert alert-secondary mt-5" role="alert"></div>
    <div id="xDepletion" class="alert alert-warning mt-3" role="alert"></div>

    <!-- Chart -->
    <div class="card mt-4">
      <div class="card-body">
        <canvas id="valueChart" height="120"></canvas>
      </div>
    </div>

    <!-- Add Entry Form -->
    <form id="entryForm" class="row row-cols-lg-auto g-2 align-items-end mt-4">
      <div class="col-12 col-lg-2">
        <label class="form-label" for="categorySelect">Category</label>
        <select id="categorySelect" class="form-select" required></select>
      </div>
      <div class="col-12 col-lg-2">
        <label class="form-label" for="dateInput">YYYYMM</label>
        <input type="text" pattern="\\d{6}" id="dateInput" class="form-control" required>
      </div>
      <div class="col-12 col-lg-2">
        <label class="form-label" for="amountInput">Amount (±)</label>
        <input type="number" step="any" id="amountInput" class="form-control" required>
      </div>
      <div class="col-12 col-lg-2">
        <label class="form-label" for="timeInput">Time (days)</label>
        <input type="number" step="any" id="timeInput" class="form-control" required>
      </div>
      <div class="col-12 col-lg-1">
        <button class="btn btn-primary w-100" type="submit">Add</button>
      </div>
    </form>

    <!-- Category management -->
    <form id="categoryForm" class="row row-cols-lg-auto g-2 align-items-end mt-3">
      <div class="col-12 col-lg-2">
        <label class="form-label" for="newCategoryInput">New Category</label>
        <input type="text" id="newCategoryInput" class="form-control">
      </div>
      <div class="col-12 col-lg-1">
        <button class="btn btn-secondary w-100" type="submit">Add Category</button>
      </div>
    </form>

    <!-- Import / Export / Clear -->
    <div class="d-flex align-items-center gap-2 mt-3">
      <button id="exportBtn" class="btn btn-success">Export JSON</button>
      <label class="btn btn-outline-secondary mb-0">
        Import JSON <input type="file" id="importInput" accept="application/json" hidden>
      </label>
      <button id="clearBtn" class="btn btn-danger">Clear Data</button>
    </div>
  </div>

  <script>
  (async () => {
    const DB_NAME = 'c25DB';
    const STORE = 'config';
    const KEY = 'data';
    const goal = 4100;
    let chartInstance;

    // ***** IndexedDB helpers *****
    function openDB() {
      return new Promise((res, rej) => {
        const rq = indexedDB.open(DB_NAME, 1);
        rq.onupgradeneeded = () => rq.result.createObjectStore(STORE);
        rq.onsuccess = () => res(rq.result);
        rq.onerror = () => rej(rq.error);
      });
    }
    function idbGet(db) {
      return new Promise((res, rej) => {
        const tr = db.transaction(STORE);
        const rq = tr.objectStore(STORE).get(KEY);
        rq.onsuccess = () => res(rq.result);
        rq.onerror = () => rej(rq.error);
      });
    }
    function idbSet(db, val) {
      return new Promise((res, rej) => {
        const tr = db.transaction(STORE, 'readwrite');
        tr.objectStore(STORE).put(val, KEY);
        tr.oncomplete = () => res();
        tr.onerror = () => rej(tr.error);
      });
    }

    const db = await openDB();
    let data = await idbGet(db);
    if (!data) {
      // Fallback to bundled JSON then persist
      data = await fetch('config/c25.json').then(r => r.json());
      await idbSet(db, data);
    }

    const dateInput = document.getElementById('dateInput');
    function setCurrentYM() {
      const d = new Date();
      dateInput.value = d.getFullYear().toString() + String(d.getMonth() + 1).padStart(2, '0');
    }

    const categorySelect = document.getElementById('categorySelect');
    function populateCategories() {
      categorySelect.innerHTML = '';
      Object.keys(data).forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k;
        categorySelect.appendChild(opt);
      });
    }

    // ***** Rendering *****
    function render() {
      // progress bars
      const container = document.getElementById('progressContainer');
      container.innerHTML = '';
      const labels = [];
      const values = [];
      let positiveTotal = 0;
      let xValue = 0;
      let xTime = 0;
      let aggregateValue = 0;
      let aggregateTime = 0;

      Object.entries(data).forEach(([key, entries]) => {
        let valueSum = 0;
        let timeSum = 0;
        Object.values(entries).forEach(e => {
          valueSum += e.value;
          timeSum += e.time;
        });
        const rate = timeSum ? valueSum / timeSum : 0;
        labels.push(key);
        values.push(valueSum);

        if (key !== 'b1' && key !== 'x') {
          aggregateValue += valueSum;
          aggregateTime += timeSum;
        }
        if (key !== 'x') {
          positiveTotal += valueSum;
        } else {
          xValue = valueSum;
          xTime = timeSum;
        }

        const div = document.createElement('div');
        div.className = 'mb-3';
        if (key !== 'x') {
          const pct = (valueSum / goal) * 100;
          let note = '';
          if (rate > 0 && valueSum < goal) {
            const days = (goal - valueSum) / rate;
            const targetDate = new Date(Date.now() + days * 86400000);
            note = `At this pace, it would take ${Math.round(days).toLocaleString()} days to reach ${goal} — that's on ${targetDate.toISOString().split('T')[0]}.`;
          }
          div.innerHTML = `
            <h5>${key} (${valueSum} / ${goal})</h5>
            <div class="progress">
              <div class="progress-bar ${pct>=100?'bg-success':'bg-info'}" role="progressbar"
                   style="width: ${Math.min(pct, 100).toFixed(2)}%;" aria-valuenow="${pct.toFixed(2)}"
                   aria-valuemin="0" aria-valuemax="100">${pct.toFixed(2)}%</div>
            </div>
            ${note ? `<small class="text-muted">${note}</small>` : ''}
          `;
        } else {
          div.innerHTML = `
            <h5>${key} (${valueSum})</h5>
            <small class="text-muted">Rate: ${rate.toFixed(2)} per day</small>
          `;
        }
        container.appendChild(div);
      });

      // Aggregate alerts
      const aggRate = aggregateTime ? aggregateValue / aggregateTime : 0;
      const aggregateEl = document.getElementById('aggregate');
      if (aggRate > 0) {
        const days = goal / aggRate;
        const date = new Date(Date.now() + days * 86400000);
        aggregateEl.textContent = `At this combined pace, it would take ${Math.round(days).toLocaleString()} days to reach ${goal} — that's on ${date.toISOString().split('T')[0]}.`;
      } else {
        aggregateEl.textContent = 'Insufficient data for aggregate projection.';
      }

      const xEl = document.getElementById('xDepletion');
      if (xTime > 0 && xValue < 0) {
        const xRate = xValue / xTime;
        const daysDeplete = positiveTotal / -xRate;
        const depleteDate = new Date(Date.now() + daysDeplete * 86400000);
        xEl.textContent = `At x's pace, all positive balances would be depleted in ${Math.round(daysDeplete).toLocaleString()} days — that's on ${depleteDate.toISOString().split('T')[0]}.`;
      } else {
        xEl.textContent = '';
      }

      // Chart
      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(document.getElementById('valueChart'), {
        type: 'bar',
        data: {
          labels,
          datasets: [{ label: 'Current Value', data: values, borderWidth: 1 }]
        },
        options: {
          scales: { y: { beginAtZero: true, max: goal } }
        }
      });
    }

    populateCategories();
    render();
    setCurrentYM();

    // ***** Add Entry *****
    document.getElementById('entryForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const cat = categorySelect.value;
      const ym = dateInput.value.trim();
      const amount = parseFloat(document.getElementById('amountInput').value);
      const time = parseFloat(document.getElementById('timeInput').value);
      if (!/^[0-9]{6}$/.test(ym) || isNaN(amount) || isNaN(time)) return alert('Invalid input');
      data[cat] ||= {};
      data[cat][ym] ||= { value: 0, time: 0 };
      data[cat][ym].value += amount;
      data[cat][ym].time += time;
      await idbSet(db, data);
      render();
      setCurrentYM();
      document.getElementById('amountInput').value = '';
      document.getElementById('timeInput').value = '';
    });

    // ***** Export *****
    document.getElementById('exportBtn').addEventListener('click', async () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), { href: url, download: 'c25-export.json' });
      a.click();
      URL.revokeObjectURL(url);
    });

    // ***** Import *****
    document.getElementById('importInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const imported = JSON.parse(await file.text());
        data = imported;
        await idbSet(db, data);
        populateCategories();
        render();
        e.target.value = '';
      } catch (err) {
        alert('Invalid JSON file');
      }
    });

    // ***** Add Category *****
    document.getElementById('categoryForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const name = document.getElementById('newCategoryInput').value.trim();
      if (!name || data[name]) return;
      data[name] = {};
      await idbSet(db, data);
      populateCategories();
      categorySelect.value = name;
      document.getElementById('newCategoryInput').value = '';
    });

    // ***** Clear Data *****
    document.getElementById('clearBtn').addEventListener('click', async () => {
      if (!confirm('Clear all stored data?')) return;
      data = {};
      await idbSet(db, data);
      populateCategories();
      render();
      setCurrentYM();
    });
  })();
  </script>
</body>
</html>
