<!DOCTYPE html>
<html lang="en">
<head>
    <script src="common/random-utils.js"></script>
  <meta charset="UTF-8">
  <title>LoopTube</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { padding:1rem; }
    #player{ width:100%; height:100%; }
  </style>
</head>
<body class="text-center">
<div class="container">
  <h1 class="h3">LoopTube</h1>
  <div id="globalStats" class="small mb-3"></div>
  <div class="input-group mb-3">
    <input id="urlInput" type="text" class="form-control" placeholder="YouTube URL">
    <button id="loadBtn" class="btn btn-primary">Load</button>
  </div>
  <div class="ratio ratio-16x9 mb-3" id="player"></div>
  <div class="progress mb-2" style="height:8px;">
    <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width:100%"></div>
  </div>
  <div id="statsInfo" class="mb-2 small"></div>
  <div id="srsButtons" class="btn-group mb-3" style="display:none;">
    <button class="btn btn-secondary" data-rating="2">Very Hard</button>
    <button class="btn btn-warning"  data-rating="3">Hard</button>
    <button class="btn btn-primary"  data-rating="4">Medium</button>
    <button class="btn btn-success"  data-rating="5">Easy</button>
  </div>
  <button id="nextSegment" class="btn btn-info mb-3" style="display:none;">View Next Video Based on SRS Algorithm</button>
  <div id="controls" class="btn-group mb-3" role="group">
    <button id="setStart" class="btn btn-secondary">Set A</button>
    <button id="setEnd" class="btn btn-secondary">Set B</button>
    <button id="toggleLoop" class="btn btn-secondary">Start Loop</button>
    <button id="randomSeg" class="btn btn-secondary">Random Segment</button>
    <button id="shareBtn" class="btn btn-success">Share</button>
  </div>
  <div class="mb-3">
    <button id="exportBtn" class="btn btn-outline-secondary btn-sm">Export CSV</button>
    <input type="file" id="importFile" accept=".csv" class="form-control form-control-sm" style="display:inline-block;width:auto">
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
/* ==== BEGIN Skyway algorithm helpers (copied from skyway.html) ==== */
const urlParams   = new URLSearchParams(location.search);
const targetCsv   = urlParams.get('target');
let   distributionArr = null;
const distributionStr = urlParams.get('distribution');
if (distributionStr) {
  distributionArr = distributionStr.split(/[-,]/).map(n => parseInt(n.trim(),10)).filter(n => !isNaN(n) && n>0);
}
let distributionPool = [];
const distributionsStr = urlParams.get('distributions');
if (distributionsStr) {
  const distEntries = distributionsStr.split(/[;|]/);
  for (const entry of distEntries) {
    const [distPart,wPart] = entry.split(/[:=]/);
    if (!distPart || !wPart) continue;
    const w = parseInt(wPart.trim(),10);
    if (w<=0 || isNaN(w)) continue;
    const arr = distPart.split(/[-,]/).map(x => parseInt(x.trim(),10)).filter(x => !isNaN(x)&&x>0);
    if (arr.length) distributionPool.push({arr,weight:w});
  }
}
let randomMode = (urlParams.get('randomMode') || 'weighted').toLowerCase();
const modeWeightsStr = urlParams.get('modeWeights');
if (modeWeightsStr) {
  const allowed = new Set(['weighted','uniform','contiguous','segments']);
  const mwList = modeWeightsStr.split(/[;,]/).map(p=>p.trim()).filter(Boolean).map(p=>{const[k,v]=p.split(/[:=|]/);return{mode:k?.trim().toLowerCase(),w:parseInt(v?.trim(),10)}}).filter(o=>allowed.has(o.mode)&&o.w>0&&!isNaN(o.w));
  if (mwList.length) {
    const tot = mwList.reduce((s,m)=>s+m.w,0);
    let rnd = randInt(1,tot);
    for (const m of mwList){ if(rnd<=m.w){ randomMode=m.mode; break;} rnd-=m.w; }
  }
}
if ((distributionArr && distributionArr.length) || distributionPool.length)
  randomMode='segments';
let configValues={};
async function loadConfig(){ if(Object.keys(configValues).length) return configValues; try{ const resp=await fetch('config/values.json'); if(resp.ok){ const raw=await resp.json(); const base=raw.base||{}; let patch={}; if(Array.isArray(raw.patches)&&raw.patches.length){ const weights=raw.patches.map(p=>Number(p.distributionWeight)||1); const tot=weights.reduce((a,b)=>a+b,0); let rnd=getSecureRandomNumber()*tot; for(let i=0;i<raw.patches.length;i++){ if(rnd<weights[i]){ patch={...raw.patches[i]}; break;} rnd-=weights[i]; } delete patch.distributionWeight; } configValues=Object.assign({},base,patch); } }catch(err){ console.error('Config load failed:',err);} return configValues; }
function pickIdxByWeights(freq){ const tot=freq.reduce((s,v)=>s+v,0); let rnd=randInt(1,tot); for(let i=0;i<freq.length;i++){ if(rnd<=freq[i]) return i; rnd-=freq[i]; } return freq.length-1; }
function cleanCell(c){ return c.trim().replace(/^["']+|["']+$/g,''); }
function parseCsvLine(l){ const out=[]; let cell='',inQ=false; for(let i=0;i<l.length;i++){ const ch=l[i]; if(ch==='"'){ if(inQ&&l[i+1]==='"'){cell+='"';i++;} else inQ=!inQ;} else if(ch===','&&!inQ){ out.push(cell); cell=''; } else cell+=ch; } out.push(cell); return out; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(getSecureRandomNumber()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function tryEvalExpr(str){ if(!/^[0-9+\-*/ ().]+$/.test(str)) return str; try{ const v=Function('"use strict";return ('+str+')')(); return Number.isFinite(v)?String(v):str; }catch{ return str; } }
function applyConfig(rows){ const re=/\{([^}]+)}/g; return rows.map(r=>r.map(c=>{ const sub=c.replace(re,(m,p)=>Object.prototype.hasOwnProperty.call(configValues,p)?configValues[p]:m); return tryEvalExpr(sub);})); }
async function fetchCSV(name){ await loadConfig(); try{ const res=await fetch(name); if(!res.ok) throw new Error(`${res.status} ${res.statusText}`); const raw=(await res.text()).split('\n').map(l=>l.trim()).filter(Boolean); let rows=raw.map(l=>parseCsvLine(l).map(cleanCell)); rows=applyConfig(rows); if(!['contiguous','segments'].includes(randomMode)) shuffle(rows); return rows; }catch(e){ throw new Error('Error fetching "'+name+'": '+e.message); }}
function pickUniform(rows){ return rows[randInt(0,rows.length-1)]; }
function pickWeighted(rows){ const list=rows.map(r=>({r,w:Math.max(1,parseInt(r[1],10)||1)})); const tot=list.reduce((s,x)=>s+x.w,0); let rnd=getSecureRandomNumber()*tot; for(const x of list){ if(rnd<x.w) return x.r; rnd-=x.w; } return list[list.length-1].r; }
function pickContiguous(rows){ const tot=rows.reduce((s,r)=>s+Math.max(1,parseInt(r[1],10)||1),0); let rnd=randInt(1,tot); for(const r of rows){ const w=Math.max(1,parseInt(r[1],10)||1); if(rnd<=w) return r; rnd-=w; } return rows[rows.length-1]; }
function pickSegments(rows){ let freq=null; if(distributionPool.length){ const weights=distributionPool.map(d=>d.weight); freq=distributionPool[pickIdxByWeights(weights)].arr.slice(); } else if(distributionArr&&distributionArr.length){ freq=distributionArr.slice(); } else return pickUniform(rows); const nRows=rows.length; if(freq.length>nRows){ const extra=freq.slice(nRows).reduce((s,v)=>s+v,0); freq=freq.slice(0,nRows); freq[nRows-1]+=extra; } const nReg=freq.length; const base=Math.floor(nRows/nReg); let rem=nRows%nReg; const bounds=[]; let start=0; for(let i=0;i<nReg;i++){ const sz=base+(i<rem?1:0); bounds.push([start,start+sz-1]); start+=sz; } const regIdx=pickIdxByWeights(freq); const [l,r]=bounds[regIdx]; return rows[randInt(l,r)]; }
function pickRow(rows){ switch(randomMode){ case 'uniform': return pickUniform(rows); case 'contiguous': return pickContiguous(rows); case 'segments': return pickSegments(rows); case 'weighted': default: return pickWeighted(rows); }}
async function processRows(rows,depth=0){ if(depth>2000) return document.body.textContent='Max CSV nesting depth exceeded.'; if(!rows.length) return document.body.textContent='CSV empty.'; for(const r of rows){ if(r[0].trim()==='csv' && parseInt(r[1],10)===0){ try{ r[1]=(await fetchCSV(r[2])).length.toString(); }catch(e){ console.error(e); r[1]='1'; } } } const sel=pickRow(rows); const type=sel[0].trim(); if(type==='link'){ if(sel.length>=4 && /^https?:\/\/(www\.)?(youtube\.com|youtu\.be)/.test(sel[2])){ const seg=parseInt(sel[3],10); if(!isNaN(seg)&&seg>1){ const qs=new URLSearchParams(); qs.set('video',sel[2]); qs.set('segments',seg); location.href='looptube.html?'+qs.toString(); return; } } location.href=sel[2]; return; } if(type==='git-specific'){ const user=sel[2].split('=')[1], repo=sel[3].split('=')[1]; const list=sel[4].split('=')[1].split('_'); location.href=`https://github.com/${user}/${repo}/issues/${list[randInt(0,list.length-1)]}`; return; } if(type==='git-range'){ const user=sel[2].split('=')[1], repo=sel[3].split('=')[1]; const [min,max]=sel[4].split('=')[1].split('_').map(Number); if(isNaN(min)||isNaN(max)) return document.body.textContent='Bad git-range row'; location.href=`https://github.com/${user}/${repo}/issues/${randInt(min,max)}`; return; } if(type==='csv'){ try{ return processRows(await fetchCSV(sel[2]),depth+1); }catch(e){ return document.body.textContent=e.message; } } document.body.textContent='Unknown row type: '+type; }
/* ==== END Skyway algorithm helpers ==== */
</script>
<script>
let player;
let startTime=0;
let endTime=0;
let loopActive=false;
let segmentId='';
let currentRec=null;
let awaitingNext=false;

// ==== IndexedDB ==== //
const DB_NAME='looptubeHistory';
const STORE='segments';
let dbPromise=null;
function openDB(){
  if(dbPromise) return dbPromise;
  dbPromise=new Promise((res,rej)=>{
    const req=indexedDB.open(DB_NAME,1);
    req.onupgradeneeded=e=>{
      const db=e.target.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'});
    };
    req.onsuccess=e=>res(e.target.result);
    req.onerror=e=>rej(e.target.error);
  });
  return dbPromise;
}
async function getSeg(id){
  const db=await openDB();
  return new Promise((res,rej)=>{
    const req=db.transaction(STORE,'readonly').objectStore(STORE).get(id);
    req.onsuccess=()=>res(req.result||{id,views:0,totalSecs:0,reps:0,ease:2.5,intervalH:24,last:0,next:0});
    req.onerror=()=>rej(req.error);
  });
}
async function putSeg(rec){
  const db=await openDB();
  return new Promise((res,rej)=>{
    const req=db.transaction(STORE,'readwrite').objectStore(STORE).put(rec);
    req.onsuccess=()=>res();
    req.onerror=()=>rej(req.error);
  });
}
async function getAllSeg(){
  const db=await openDB();
  return new Promise((res,rej)=>{
    const req=db.transaction(STORE,'readonly').objectStore(STORE).getAll();
    req.onsuccess=()=>res(req.result||[]);
    req.onerror=()=>rej(req.error);
  });
}

async function setupSegment(){
  segmentId = extractVideoId(player.getVideoUrl())+'_'+Math.round(startTime)+'-'+Math.round(endTime);
  currentRec = await getSeg(segmentId);
  await putSeg(currentRec);
  await updateStatsDisplay();
  await updateGlobalStats();
  awaitingNext=false;
  hideNextBtn();
}

async function updateStatsDisplay(){
  if(!currentRec) return;
  const all = await getAllSeg();
  const total = all.reduce((s,r)=>s+r.totalSecs,0);
  const pct = total? ((currentRec.totalSecs/total)*100).toFixed(2) : '0';
  const minutes = currentRec.totalSecs/60;
  const timeStr = minutes < 60 ? `${minutes.toFixed(1)} minutes` : `${(minutes/60).toFixed(1)} hours`;
  document.getElementById('statsInfo').innerHTML = `You've viewed this ${currentRec.views} times for a total of ${timeStr}!<br>Among all the videos you've viewed, this segment comprises ${pct}% of the whole!`;
}

async function updateGlobalStats(){
  const all = await getAllSeg();
  if(!all.length){
    document.getElementById('globalStats').textContent='';
    return;
  }
  const totalSecs = all.reduce((s,r)=>s+r.totalSecs,0);
  const minutes = totalSecs/60;
  const timeStr = minutes < 60 ? `${minutes.toFixed(1)} minutes` : `${(minutes/60).toFixed(1)} hours`;
  const earliest = all.reduce((m,r)=> (r.last>0 && (m===0||r.last<m))?r.last:m,0);
  const dateStr = earliest? new Date(earliest).toLocaleDateString(): 'N/A';
  document.getElementById('globalStats').textContent = `total: ${all.length} segments viewed in ${timeStr} since ${dateStr}`;
}

function showSrsButtons(){
  document.getElementById('srsButtons').style.display='block';
}
function hideSrsButtons(){
  document.getElementById('srsButtons').style.display='none';
}
function showNextBtn(){
  document.getElementById('nextSegment').style.display='block';
}
function hideNextBtn(){
  document.getElementById('nextSegment').style.display='none';
}

async function findNextSegment(){
  const all = await getAllSeg();
  if(!all.length) return null;
  all.sort((a,b)=>(a.next||0)-(b.next||0));
  return all[0];
}

function segToUrl(rec){
  const [vid,s,e] = rec.id.split('_');
  const u = new URL(location.pathname, location.origin);
  u.searchParams.set('video',vid);
  u.searchParams.set('start',s);
  u.searchParams.set('end',e);
  return u.toString();
}

function sm2Ease(ease,q){
  const newEase = ease + 0.1 - (5-q)*(0.08+(5-q)*0.02);
  return Math.max(1.3,newEase);
}

async function onSegmentEnd(){
  const segLen=endTime-startTime;
  currentRec.views+=1;
  currentRec.totalSecs+=segLen;
  await putSeg(currentRec);
  await updateStatsDisplay();
  await updateGlobalStats();
  if(!awaitingNext) hideNextBtn();
  showSrsButtons();
  if(!awaitingNext){
    player.seekTo(startTime,true);
    player.playVideo();
    requestAnimationFrame(checkLoop);
  }
}

async function rateQuality(q){
  currentRec = await getSeg(segmentId); // refresh
  if(q<3){
    currentRec.reps=0;
    currentRec.intervalH=24;
  }else{
    currentRec.reps=(currentRec.reps||0)+1;
    if(currentRec.reps===1) currentRec.intervalH=24;
    else if(currentRec.reps===2) currentRec.intervalH=144;
    else currentRec.intervalH=Math.round(currentRec.intervalH*currentRec.ease);
  }
  currentRec.ease = sm2Ease(currentRec.ease,q);
  currentRec.last=Date.now();
  currentRec.next=currentRec.last+currentRec.intervalH*3600000;
  await putSeg(currentRec);
  await updateGlobalStats();
  awaitingNext=true;
  hideSrsButtons();
  showNextBtn();
  player.pauseVideo();
  loopActive=false;
}

document.querySelectorAll('#srsButtons button').forEach(btn=>{
  btn.addEventListener('click',()=>rateQuality(parseInt(btn.dataset.rating,10)));
});

document.getElementById('nextSegment').onclick=async()=>{
  const rec = await findNextSegment();
  if(rec) location.href = segToUrl(rec);
  else alert('No history available');
};

document.getElementById('exportBtn').onclick=async()=>{
  const recs=await getAllSeg();
  let csv='id,views,totalSecs,reps,ease,intervalH,last,next\n';
  for(const r of recs){
    csv+=`${r.id},${r.views},${r.totalSecs},${r.reps},${r.ease},${r.intervalH},${r.last},${r.next}\n`;
  }
  const blob=new Blob([csv],{type:'text/csv'});
  const link=document.createElement('a');
  link.href=URL.createObjectURL(blob);
  link.download='looptube_history.csv';
  link.click();
};

document.getElementById('importFile').onchange=async(e)=>{
  const f=e.target.files[0];
  if(!f) return;
  const text=await f.text();
  const lines=text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  for(const line of lines.slice(1)){
    const [id,v,t,r,ease,intH,last,next]=line.split(',');
    if(!id) continue;
    const rec={id,views:+v,totalSecs:+t,reps:+r,ease:+ease,intervalH:+intH,last:+last,next:+next};
    await putSeg(rec);
  }
  alert('Import complete');
  await updateGlobalStats();
};
function onYouTubeIframeAPIReady(){ createPlayer(initialVideoId()); }
function createPlayer(id){ if(player) player.destroy(); player=new YT.Player('player',{height:'100%',width:'100%',videoId:id,events:{onReady:onPlayerReady}}); }
async function onPlayerReady(){
  const s=parseFloat(urlParams.get('start'));
  const e=parseFloat(urlParams.get('end'));
  const segCount=parseInt(urlParams.get('segments')||'0',10);
  if(!isNaN(s) && !isNaN(e)){
    startTime=s; endTime=e;
  } else if(segCount>1){
    await pickRandomSegment(segCount);
    return;
  } else {
    startTime=0;
    endTime=player.getDuration();
  }
  await setupSegment();
  player.seekTo(startTime,true);
  player.playVideo();
  loopActive=true;
  checkLoop();
}
function initialVideoId(){ const direct=urlParams.get('video'); if(direct) return extractVideoId(direct); return ''; }
function extractVideoId(url){ const m=url.match(/[?&]v=([^&]+)/); if(m) return m[1]; const m2=url.match(/youtu\.be\/([^?]+)/); if(m2) return m2[1]; return url; }
function loadVideo(){ const url=document.getElementById('urlInput').value.trim(); if(!url) return; const id=extractVideoId(url); createPlayer(id); }
document.getElementById('loadBtn').onclick=loadVideo;
document.getElementById('setStart').onclick=()=>{ if(player){ startTime=player.getCurrentTime(); }};
document.getElementById('setEnd').onclick=()=>{ if(player){ endTime=player.getCurrentTime(); }};
document.getElementById('toggleLoop').onclick=()=>{ loopActive=!loopActive; if(loopActive) checkLoop(); };
document.getElementById('randomSeg').onclick=async()=>{ if(player){ const n=parseInt(prompt('Segments?'),10); if(n>1) await pickRandomSegment(n); }};
document.getElementById('shareBtn').onclick=async()=>{
  await loadConfig();
  const repo=(configValues.stashUsername&&configValues.stashRepository)?
    `${configValues.stashUsername}/${configValues.stashRepository}`:
    (configValues['current-era-stash']||'cjcaf1995/stash3');
  const u=new URL(location.href);
  if(!u.searchParams.get('video')&&player){
    u.searchParams.set('video',extractVideoId(player.getVideoUrl()));
  }
  u.searchParams.set('start',Math.round(startTime));
  u.searchParams.set('end',Math.round(endTime));
  try{ await navigator.clipboard.writeText(u.toString()); }catch(e){ console.error('copy failed',e); }
  location.href=`https://github.com/${repo}/issues/new/choose`;
};
async function pickRandomSegment(n){
  const dur=player.getDuration();
  if(!dur) return;
  const segLen=dur/n;
  const idx=randInt(0,n-1);
  startTime=idx*segLen;
  endTime=(idx+1)*segLen;
  await setupSegment();
  player.seekTo(startTime,true);
  player.playVideo();
  loopActive=true;
  checkLoop();
}
function checkLoop(){
  if(!loopActive) return;
  const t = player.getCurrentTime();
  const len = endTime - startTime;
  if(len>0){
    const rem = Math.max(0, endTime - t);
    document.getElementById('progressBar').style.width = (rem/len*100)+'%';
  }
  if(t >= endTime){
    onSegmentEnd();
    return;
  }
  requestAnimationFrame(checkLoop);
}
window.addEventListener('keydown',e=>{ if(e.code==='Space'){ e.preventDefault(); if(player.getPlayerState()==YT.PlayerState.PLAYING) player.pauseVideo(); else player.playVideo(); } else if(e.key==='a'){ if(player) startTime=player.getCurrentTime(); } else if(e.key==='b'){ if(player) endTime=player.getCurrentTime(); } else if(e.key==='l'){ loopActive=!loopActive; if(loopActive) checkLoop(); } });
window.onload=async ()=>{
  await loadConfig();
  await updateGlobalStats();
  if(targetCsv){
    try{ await processRows(await fetchCSV(targetCsv)); }
    catch(e){ document.body.textContent=e.message; }
  } else if(urlParams.get('video')){
    loadVideo();
  }
};
</script>
</body>
</html>
