<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>skyway.html – multi-mode randomizer (weighted / uniform / distribution + custom distribution string)</title>
</head>
<body>
<script>
/* ──────────────── URL PARAMS ──────────────── */
const params                = new URLSearchParams(location.search);
const targetCsv             = params.get('target');                       // required
const randomMode            = (params.get('randomMode') || 'weighted').toLowerCase();
const distributionParamRaw  = params.get('distribution') || '';

//  ▸  "weighted"     – current default behaviour (rows may be shuffled; weight column used).
//  ▸  "uniform"      – every row has equal chance, ignoring weight column.
//  ▸  "distribution" – sequential-range selection. If &distribution=1-2-3… is supplied, the custom
//                        frequency string skews the selection toward left / centre / right depending
//                        on the pattern.

/* ──────────────── CONFIG HANDLING ──────────────── */
let configValues = {};
async function loadConfig() {
  if (Object.keys(configValues).length) return configValues;
  try {
    const resp = await fetch('config/values.json');
    if (resp.ok) configValues = await resp.json();
  } catch (err) {
    console.error('Failed to load config:', err);
  }
  return configValues;
}

/* ──────────────── RANDOM HELPERS ──────────────── */
function getSecureRandomNumber() {
  const a = new Uint32Array(1);
  crypto.getRandomValues(a);
  return a[0] / (0xFFFFFFFF + 1);
}

/* ──────────────── CSV UTILITIES ──────────────── */
function cleanCell(c) { return c.trim().replace(/^(["']+)|(["']+)$/g, ''); }

function parseCsvLine(line) {
  const out = []; let cell = '', inQ = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQ && i + 1 < line.length && line[i + 1] === '"') { cell += '"'; i++; }
      else inQ = !inQ;
    } else if (ch === ',' && !inQ) { out.push(cell); cell = ''; }
    else cell += ch;
  }
  out.push(cell);
  return out;
}

function shuffle(arr) {                // Fisher-Yates, cryptographically seeded
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(getSecureRandomNumber() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ────────── NUMERIC-EXPR + PLACEHOLDER SUBSTITUTION ────────── */
function tryEvalNumericExpression(str) {
  if (!/^[-+*/0-9 ().]+$/.test(str)) return str;
  try {
    // eslint-disable-next-line no-new-func
    const val = Function('"use strict";return (' + str + ')')();
    return Number.isFinite(val) ? String(val) : str;
  } catch { return str; }
}

function applyConfigPlaceholders(rows) {
  const re = /\{([^}]+)}/g;
  return rows.map(r => r.map(cell => {
    const substituted = cell.replace(re, (m, p1) =>
      Object.prototype.hasOwnProperty.call(configValues, p1) ? configValues[p1] : m
    );
    return tryEvalNumericExpression(substituted);
  }));
}

/* ──────────────── DISTRIBUTION PARAM PARSING ──────────────── */
const distributionArray = distributionParamRaw
  .split(/[-,]/)                       // accept 1-2-3 or 1,2,3
  .map(n => parseInt(n.trim(), 10))
  .filter(n => !isNaN(n) && n > 0);

function getRandomIndexByFrequency(freqArr) {
  const total = freqArr.reduce((s, x) => s + x, 0);
  let r = getSecureRandomNumber() * total;
  for (let i = 0; i < freqArr.length; i++) {
    if (r < freqArr[i]) return i;
    r -= freqArr[i];
  }
  return freqArr.length - 1;           // fallback
}

function pickRowDistributionCustom(rows, freqArr) {
  const totalRows   = rows.length;
  const regionCount = freqArr.length;
  if (regionCount === 0 || totalRows === 0) return rows[0];

  // Split rows into contiguous regions as evenly as possible
  const baseSize  = Math.floor(totalRows / regionCount);
  const remainder = totalRows % regionCount;
  const boundaries = [];
  let currentStart = 0;
  for (let i = 0; i < regionCount; i++) {
    const size = baseSize + (i < remainder ? 1 : 0);
    const regionEnd = currentStart + size - 1;
    boundaries.push([currentStart, regionEnd]);
    currentStart = regionEnd + 1;
  }

  // Choose region using the supplied frequency array
  const chosenRegion = boundaries[getRandomIndexByFrequency(freqArr)];
  const idx = chosenRegion[0] + Math.floor(getSecureRandomNumber() * (chosenRegion[1] - chosenRegion[0] + 1));
  return rows[idx];
}

/* ──────────────── FETCH CSV (respect randomMode) ──────────────── */
async function fetchCSV(name) {
  await loadConfig();
  try {
    const res = await fetch(name);
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    const lines = res.text ? (await res.text()).split(/\r?\n/) : [];
    let rows = lines.map(l => l.trim()).filter(Boolean)
                    .map(l => parseCsvLine(l).map(cleanCell));
    rows = applyConfigPlaceholders(rows);

    // Only shuffle for modes that do NOT rely on original order.
    if (randomMode !== 'distribution') shuffle(rows);
    return rows;
  } catch (e) {
    throw new Error('Error fetching "' + name + '": ' + e.message);
  }
}

/* ──────────────── ROW-PICKING STRATEGIES ──────────────── */
function pickRowUniform(rows) {
  return rows[Math.floor(getSecureRandomNumber() * rows.length)];
}

function pickRowWeighted(rows) {
  const wr = rows.map(r => ({ row: r, w: Math.max(1, parseInt(r[1], 10) || 1) }));
  const total = wr.reduce((s, x) => s + x.w, 0);
  let rand = getSecureRandomNumber() * total;
  for (const x of wr) { if (rand < x.w) return x.row; rand -= x.w; }
  return wr[wr.length - 1].row;        // fallback
}

// Original sequential distribution (contiguous weight blocks, order preserved)
function pickRowDistributionClassic(rows) {
  const total = rows.reduce((s, r) => s + Math.max(1, parseInt(r[1], 10) || 1), 0);
  let rand = Math.floor(getSecureRandomNumber() * total) + 1; // 1-based
  for (const r of rows) {
    const w = Math.max(1, parseInt(r[1], 10) || 1);
    if (rand <= w) return r;
    rand -= w;
  }
  return rows[rows.length - 1];        // fallback
}

function pickRow(rows) {
  switch (randomMode) {
    case 'uniform':
      return pickRowUniform(rows);
    case 'distribution':
      if (distributionArray.length) return pickRowDistributionCustom(rows, distributionArray);
      return pickRowDistributionClassic(rows);
    case 'weighted':
    default:
      return pickRowWeighted(rows);
  }
}

/* ──────────────── MAIN PROCESSOR ──────────────── */
async function processRows(rows, depth = 0) {
  if (depth > 2000) return document.body.textContent = 'Max CSV nesting depth exceeded.';
  if (!rows.length)  return document.body.textContent = 'CSV empty.';

  /* Auto-weight patch: if a row’s weight is zero, replace with child-CSV length */
  for (const r of rows) {
    if (r[0].trim() === 'csv' && parseInt(r[1], 10) === 0) {
      try { r[1] = (await fetchCSV(r[2])).length.toString(); }
      catch (e) { console.error(e); r[1] = '1'; }
    }
  }

  const sel  = pickRow(rows);
  const type = sel[0].trim().toLowerCase();

  if (type === 'link') {
    location.href = sel[2];
    return;
  }

  if (type === 'git-specific') {
    const user  = sel[2].split('=')[1],
          repo  = sel[3].split('=')[1],
          list  = sel[4].split('=')[1].split('_');
    const issue = list[Math.floor(getSecureRandomNumber() * list.length)];
    location.href = `https://github.com/${user}/${repo}/issues/${issue}`;
    return;
  }

  if (type === 'git-range') {
    const user      = sel[2].split('=')[1],
          repo      = sel[3].split('=')[1],
          [min,max] = sel[4].split('=')[1].split('_').map(Number);
    if (isNaN(min) || isNaN(max))
      return document.body.textContent = 'Bad git-range row (min/max missing).';

    // If a distribution array is supplied, skew the selection within the range
    let chosen;
    if (distributionArray.length) {
      const fullRange = [];
      for (let i = min; i <= max; i++) fullRange.push(i);
      chosen = pickRowDistributionCustom(fullRange.map(x => [x]), distributionArray)[0];
    } else {
      chosen = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    }
    location.href = `https://github.com/${user}/${repo}/issues/${chosen}`;
    return;
  }

  if (type === 'csv') {
    try { return processRows(await fetchCSV(sel[2]), depth + 1); }
    catch (e) { return document.body.textContent = e.message; }
  }

  document.body.textContent = 'Unknown row type: ' + type;
}

/* ──────────────── ENTRY POINT ──────────────── */
window.onload = async () => {
  if (!targetCsv) {
    document.body.textContent = 'Missing ?target=... URL parameter.';
    return;
  }
  try {
    await processRows(await fetchCSV(targetCsv));
  } catch (e) {
    document.body.textContent = e.message;
  }
};
</script>
</body>
</html>
