<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>skyway.html – Hierarchical Multi-Mode Randomizer</title>
</head>
<body>
<script>
/**********************************************************************
 *  HIGH-LEVEL OVERVIEW
 *  ─────────────────────
 *  1.  ?modeWeights=weighted:3,uniform:1,contiguous:2,segments:4
 *      → first chooses a **randomMode** by the given weights.
 *  2.  ?randomMode=uniform                                                   (optional fallback)
 *  3.  ?distribution=1-2-3-2-1                                               (enables segments mode)
 *
 *  Final precedence (highest → lowest):
 *    a) modeWeights (weighted selector)          ← NEW
 *    b) distribution → forces “segments”
 *    c) randomMode   → manual override
 *    d) default      → “weighted”
 **********************************************************************/

/* ──────────────── URL PARAMS ──────────────── */
const urlParams     = new URLSearchParams(location.search);
const targetCsv     = urlParams.get('target');                       // required

// -------------- parse distribution string --------------
const distributionStr   = urlParams.get('distribution');
let   distributionArr   = null;
if (distributionStr) {
  distributionArr = distributionStr
      .split(/[-,]/)
      .map(x => parseInt(x.trim(), 10))
      .filter(x => !isNaN(x) && x > 0);
}

// -------------- parse randomMode (initial) --------------
let randomMode = (urlParams.get('randomMode') || 'weighted').toLowerCase();

// -------------- parse modeWeights (highest precedence) --------------
const modeWeightsStr = urlParams.get('modeWeights');  // e.g.  weighted:3,uniform:1,contiguous:2,segments:4
if (modeWeightsStr) {
  const allowed = new Set(['weighted','uniform','contiguous','segments']);
  const pairs   = modeWeightsStr.split(/[;,]/);       // allow comma or semicolon
  const modes   = [];

  for (const p of pairs) {
    const [modeRaw,wRaw] = p.split(/[:=|-]/);         // allow :, =, -, |
    if (!modeRaw || !wRaw) continue;
    const mode = modeRaw.trim().toLowerCase();
    const w    = parseInt(wRaw.trim(), 10);
    if (allowed.has(mode) && w > 0) modes.push({mode, w});
  }
  if (modes.length) {
    const total = modes.reduce((s,m)=>s+m.w,0);
    let   r     = Math.floor(getSecureRandomNumber()*total)+1;
    for (const m of modes) {
      if (r <= m.w) { randomMode = m.mode; break; }
      r -= m.w;
    }
  }
}

// -------------- distribution still forces “segments” --------------
if (distributionArr && distributionArr.length) randomMode = 'segments';

// ——— Debug aid (remove if not wanted) ———
console.log('Chosen randomMode →', randomMode);
/* ──────────────────────────────────────── */

/* ──────────────── CONFIG HANDLING ──────────────── */
let configValues = {};
async function loadConfig() {
  if (Object.keys(configValues).length) return configValues;
  try {
    const resp = await fetch('config/values.json');
    if (resp.ok) configValues = await resp.json();
  } catch (err) { console.error('Failed to load config:', err); }
  return configValues;
}

/* ──────────────── RANDOM HELPERS ──────────────── */
function getSecureRandomNumber() {
  const a = new Uint32Array(1);
  crypto.getRandomValues(a);
  return a[0] / (0xFFFFFFFF + 1);
}
function randInt(min, max) {             // inclusive
  return Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
}
function pickIdxByWeights(freq) {
  const total = freq.reduce((s,v)=>s+v,0);
  let r = randInt(1,total);
  for (let i=0;i<freq.length;i++){ if(r<=freq[i]) return i; r-=freq[i]; }
  return freq.length-1;
}

/* ──────────────── CSV UTILITIES ──────────────── */
function cleanCell(c) { return c.trim().replace(/^["']+|["']+$/g,''); }
function parseCsvLine(line){
  const out=[];let cell='',inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch==='"'){ if(inQ && line[i+1] === '"'){cell+='"';i++;} else inQ=!inQ; }
    else if(ch===',' && !inQ){ out.push(cell); cell=''; }
    else cell+=ch;
  }
  out.push(cell); return out;
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(getSecureRandomNumber()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

/* ───── placeholder + numeric-expr substitution ───── */
function tryEvalExpr(str){
  if(!/^[0-9+\-*/ ().]+$/.test(str)) return str;
  try{ const v=Function('"use strict";return ('+str+')')();
       return Number.isFinite(v)?String(v):str;
  }catch{ return str; }
}
function applyConfig(rows){
  const re=/\{([^}]+)}/g;
  return rows.map(r=>r.map(c=>{
    const sub=c.replace(re,(m,p)=>Object.prototype.hasOwnProperty.call(configValues,p)?configValues[p]:m);
    return tryEvalExpr(sub);
  }));
}

/* ──────────────── FETCH CSV ──────────────── */
async function fetchCSV(name){
  await loadConfig();
  try{
    const res=await fetch(name);
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    const lines=(await res.text()).split('\n').map(l=>l.trim()).filter(Boolean);
    let rows  = lines.map(l=>parseCsvLine(l).map(cleanCell));
    rows = applyConfig(rows);
    if(!['contiguous','segments'].includes(randomMode)) shuffle(rows);
    return rows;
  }catch(e){ throw new Error('Error fetching "'+name+'": '+e.message);}
}

/* ──────────────── ROW-SELECTION MODES ──────────────── */
function pickUniform(rows){ return rows[randInt(0,rows.length-1)]; }
function pickWeighted(rows){
  const list=rows.map(r=>({r,w:Math.max(1,parseInt(r[1],10)||1)}));
  const tot=list.reduce((s,x)=>s+x.w,0); let rand=getSecureRandomNumber()*tot;
  for(const x of list){ if(rand<x.w) return x.r; rand-=x.w; }
  return list[list.length-1].r;
}
function pickContiguous(rows){
  const tot=rows.reduce((s,r)=>s+Math.max(1,parseInt(r[1],10)||1),0);
  let rand=randInt(1,tot);
  for(const r of rows){
    const w=Math.max(1,parseInt(r[1],10)||1);
    if(rand<=w) return r;
    rand-=w;
  }
  return rows[rows.length-1];
}
function pickSegments(rows){
  if(!distributionArr||!distributionArr.length) return pickUniform(rows);
  const nReg=distributionArr.length;
  const nRows=rows.length;
  const base=Math.floor(nRows/nReg);
  let rem=nRows%nReg;
  const regions=[]; let start=0;
  for(let i=0;i<nReg;i++){
    const size=base+(i<rem?1:0);
    regions.push([start,start+size-1]);
    start+=size;
  }
  const regIdx=pickIdxByWeights(distributionArr);
  const [l,r]=regions[Math.min(regIdx,regions.length-1)];
  return rows[randInt(l,r)];
}
function pickRow(rows){
  switch(randomMode){
    case 'uniform'    : return pickUniform(rows);
    case 'contiguous' : return pickContiguous(rows);
    case 'segments'   : return pickSegments(rows);
    case 'weighted'   :
    default           : return pickWeighted(rows);
  }
}

/* ──────────────── MAIN PROCESSOR ──────────────── */
async function processRows(rows,depth=0){
  if(depth>2000) return document.body.textContent='Max CSV nesting depth exceeded.';
  if(!rows.length) return document.body.textContent='CSV empty.';
  // auto-weight rows whose weight==0
  for(const r of rows){
    if(r[0].trim()==='csv' && parseInt(r[1],10)===0){
      try{ r[1]=(await fetchCSV(r[2])).length.toString(); }
      catch(e){ console.error(e); r[1]='1'; }
    }
  }
  const sel=pickRow(rows);
  const type=sel[0].trim();

  if(type==='link'){ location.href=sel[2]; return; }
  if(type==='git-specific'){
    const user=sel[2].split('=')[1], repo=sel[3].split('=')[1];
    const list=sel[4].split('=')[1].split('_');
    const issue=list[randInt(0,list.length-1)];
    location.href=`https://github.com/${user}/${repo}/issues/${issue}`; return;
  }
  if(type==='git-range'){
    const user=sel[2].split('=')[1], repo=sel[3].split('=')[1];
    const [min,max]=sel[4].split('=')[1].split('_').map(Number);
    if(isNaN(min)||isNaN(max)) return document.body.textContent='Bad git-range row';
    const num=randInt(min,max);
    location.href=`https://github.com/${user}/${repo}/issues/${num}`; return;
  }
  if(type==='csv'){
    try{ return processRows(await fetchCSV(sel[2]),depth+1);}
    catch(e){ return document.body.textContent=e.message;}
  }
  document.body.textContent='Unknown row type: '+type;
}

/* ──────────────── ENTRY ──────────────── */
window.onload = async ()=>{
  if(!targetCsv){ document.body.textContent='Missing ?target=…'; return; }
  try{ await processRows(await fetchCSV(targetCsv)); }
  catch(e){ document.body.textContent=e.message; }
};
</script>
</body>
</html>
