<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IndexedDB CSV + Flashcards</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome for Icons -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    body {
      background-color: #f8f9fa;
    }
    body.dark-mode {
      background-color: #343a40;
      color: #f8f9fa;
    }
    .container {
      max-width: 1000px;
      margin-top: 30px;
      margin-bottom: 100px;
    }
    .btn-draw, .btn-reveal {
      width: 100%;
      margin-bottom: 20px;
    }
    .slider-container {
      margin-bottom: 20px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
    }
    .btn-export {
      margin-top: 10px;
    }
    .gauge-container {
      margin-bottom: 20px;
    }
    .bucket-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .dark-mode .card {
      background-color: #495057;
      color: #f8f9fa;
    }
    .dark-mode .form-control, .dark-mode .form-select, .dark-mode .list-group-item {
      background-color: #6c757d;
      color: #f8f9fa;
      border: 1px solid #ced4da;
    }
    .dark-mode .btn-primary {
      background-color: #0d6efd;
      border-color: #0d6efd;
    }
    .dark-mode .btn-secondary {
      background-color: #6c757d;
      border-color: #6c757d;
    }
    /* Custom scrollbar for dark mode */
    body.dark-mode ::-webkit-scrollbar {
      width: 8px;
    }
    body.dark-mode ::-webkit-scrollbar-track {
      background: #343a40;
    }
    body.dark-mode ::-webkit-scrollbar-thumb {
      background: #6c757d;
      border-radius: 4px;
    }
    /* Flashcard styling */
    .flashcard {
      border: 2px dashed #aaa;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      margin-bottom: 20px;
      background-color: #ffffff;
    }
    body.dark-mode .flashcard {
      background-color: #444;
      border-color: #666;
    }
    .reveal-section {
      display: none; /* Hidden until "Reveal Answer" is clicked */
    }
    #frontTextContainer {
      margin-bottom: 40px;
    }
    .toast-container {
      z-index: 9999;
    }
    /* A small area for displaying DB size, etc. */
    .info-box {
      background-color: #e9ecef;
      border-radius: 5px;
      padding: 10px;
      margin-top: 10px;
    }
    .dark-mode .info-box {
      background-color: #495057;
      color: #f8f9fa;
    }
  </style>
</head>
<body>
  <!-- Display random Pantone color in top-right corner (optional) -->
  <div id="pantoneColorDisplay"
       style="position: absolute; top: 10px; right: 10px; background-color: #ffffffcc; padding: 5px; border-radius: 5px; font-weight: bold;"></div>

  <div class="container">
    <h1 class="text-center" id="pageTitle">IndexedDB CSV + Flashcards</h1>

    <!-- Theme Toggle & Help -->
    <div class="text-end mb-3">
      <button class="btn btn-secondary" onclick="toggleDarkMode()" title="Toggle Dark Mode">
        <i class="fas fa-moon"></i> Dark Mode
      </button>
      <button class="btn btn-info" data-bs-toggle="modal" data-bs-target="#helpModal" title="Help">
        <i class="fas fa-question-circle"></i> Help
      </button>
    </div>

    <!-- Upload + Text Input Row -->
    <div class="row mb-4">
      <div class="col-md-6 mb-3">
        <label class="form-label">Upload CSV(s):</label>
        <input type="file" id="csvFileInput" multiple accept=".csv" class="form-control" />
        <div class="form-text">Each CSV line is assumed "front,back". Duplicates are removed.</div>
        <button class="btn btn-primary mt-2" onclick="handleFiles()">Import to IndexedDB</button>
      </div>
      <div class="col-md-6">
        <label class="form-label">Add Text Post:</label>
        <textarea id="textPostInput" class="form-control" rows="3" placeholder="Type your text, like a GitHub Issue..."></textarea>
        <div class="form-text">We'll replace all commas with underscores and store as a single CSV row: "YYMMDD hh:mm:ss, text".</div>
        <button class="btn btn-success mt-2" onclick="addTextPost()">Add Text to DB</button>
      </div>
    </div>

    <!-- Download + DB Size Info -->
    <div class="row mb-4">
      <div class="col-md-6 mb-3">
        <button class="btn btn-dark" onclick="downloadAllRecords()">Download All as CSV</button>
        <button class="btn btn-danger ms-2" onclick="clearDatabase()">Clear IndexedDB</button>
        <div class="info-box mt-2">
          <strong>DB Size:</strong>
          <span id="dbSizeSpan">0 bytes</span>
        </div>
      </div>
      <div class="col-md-6">
        <!-- Just a placeholder area if needed -->
      </div>
    </div>

    <hr/>

    <!-- Probability Slider for Flashcard Buckets (from original snippet) -->
    <div class="slider-container">
      <label for="probSlider" class="form-label">Adjust Probabilities (Bucket1 vs Bucket2):</label>
      <input type="range" class="form-range" id="probSlider" min="0" max="100" value="33"
             oninput="updateProbabilities()" title="Probability of drawing from Bucket 1">
      <div class="slider-label">
        <span>Bucket 1: <span id="probBucket1">33%</span></span>
        <span>Bucket 2: <span id="probBucket2">67%</span></span>
      </div>
    </div>

    <!-- Draw, Reveal, Undo Buttons -->
    <button class="btn btn-primary btn-draw" onclick="drawCard()" title="Draw a card to review">
      <i class="fas fa-random"></i> Draw Card
    </button>
    <button class="btn btn-secondary btn-reveal" onclick="revealAnswer()" title="Reveal the back of the card">
      <i class="fas fa-eye"></i> Reveal Answer
    </button>
    <button class="btn btn-warning btn-draw" onclick="undoLastDraw()" title="Undo the last drawn card">
      <i class="fas fa-undo"></i> Undo Last Draw
    </button>

    <!-- Flashcard Display -->
    <div class="flashcard" id="flashcard">
      <!-- FRONT TEXT container -->
      <div id="frontTextContainer">
        <span id="frontText"></span>
      </div>
      <!-- BACK TEXT container (hidden by default until reveal) -->
      <div id="backTextContainer" class="reveal-section">
        <span id="backText"></span>
      </div>
    </div>

    <!-- Search Buttons (Google & ChatGPT); hidden until reveal -->
    <div id="googleSearchButtons" style="display: none; text-align:center; margin-bottom:20px;">
      <button class="btn btn-outline-primary" onclick="googleSearchFront()">Search Google (Front)</button>
      <button class="btn btn-outline-primary" onclick="googleSearchBack()">Search Google (Back)</button>
      <button class="btn btn-outline-success" onclick="chatGPTSearchFront()">Search ChatGPT (Front)</button>
      <button class="btn btn-outline-success" onclick="chatGPTSearchBack()">Search ChatGPT (Back)</button>
      <!-- Added Jisho.org search buttons -->
      <button class="btn btn-outline-info" onclick="jishoSearchFront()">Search Jisho (Front)</button>
      <button class="btn btn-outline-info" onclick="jishoSearchBack()">Search Jisho (Back)</button>
    </div>

    <!-- Review Gauges -->
    <div class="gauge-container">
      <label for="review1Gauge" class="form-label">Review1 (Unique Bucket1 Items / Total Cards):</label>
      <progress id="review1Gauge" class="form-range w-100" value="0" max="100" aria-label="Review1 Gauge"></progress>
      <div class="text-center">
        <span id="review1Text">0%</span>
      </div>
    </div>

    <div class="gauge-container">
      <label for="review2Gauge" class="form-label">Remaining (100% - Review1):</label>
      <progress id="review2Gauge" class="form-range w-100" value="100" max="100" aria-label="Review2 Gauge"></progress>
      <div class="text-center">
        <span id="review2Text">100%</span>
      </div>
    </div>

    <!-- Bucket Lists -->
    <div class="row">
      <div class="col-md-6">
        <h5>Bucket 1 Total Frequency: <span id="bucket1Freq">0</span></h5>
        <ul class="list-group bucket-list" id="bucket1List" aria-label="Bucket 1 Items"></ul>
      </div>
      <div class="col-md-6">
        <h5>Bucket 2 Total Frequency: <span id="bucket2Freq">0</span></h5>
        <ul class="list-group bucket-list" id="bucket2List" aria-label="Bucket 2 Items"></ul>
      </div>
    </div>

    <!-- Draw History -->
    <div class="mt-4">
      <h5>Draw History (Last 5):</h5>
      <ul class="list-group history-list" id="historyList" aria-label="Draw History"></ul>
    </div>

    <!-- Action Buttons (Export/Import/Reset) from snippet's approach -->
    <div class="text-center mt-4">
      <button class="btn btn-secondary btn-export" onclick="exportState()" title="Export current review state as JSON">
        <i class="fas fa-file-export"></i> Export Buckets
      </button>
      <button class="btn btn-secondary btn-export" onclick="importState()" title="Import an existing state from a JSON file">
        <i class="fas fa-file-import"></i> Import Buckets
      </button>
      <button class="btn btn-danger btn-export" onclick="resetBuckets()" title="Reset just the Bucket1/Bucket2 arrangement">
        <i class="fas fa-trash-alt"></i> Reset Buckets
      </button>
    </div>

    <!-- Toast Container -->
    <div aria-live="polite" aria-atomic="true" class="position-relative toast-container">
      <div id="toastContainer" class="position-fixed bottom-0 end-0 p-3" style="z-index: 11;">
        <!-- Toasts appended here -->
      </div>
    </div>

    <!-- Help Modal -->
    <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="helpModalLabel">Help & Instructions</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <h6>Overview</h6>
            <p>
              This page lets you upload CSV files or add text as CSV-like rows, storing them in IndexedDB.  
              You can then download a combined CSV with duplicates removed. Each record is assigned a unique integer <code>id</code> in ascending order.
            </p>
            <p>
              The bottom portion of the page (Flashcard Reviewer) picks random entries from two “buckets” (review vs. not-reviewed)
              according to adjustable probabilities. You can reveal answers, search them on Google/ChatGPT/Jisho, and keep track of your progress.
            </p>
            <h6>Usage Steps</h6>
            <ol>
              <li><strong>Upload CSV(s)</strong> or <strong>Add Text Post</strong>. Data is stored in IndexedDB with duplicates removed.</li>
              <li><strong>Download All as CSV</strong> to get a single combined CSV. Filenames are <code>indexedDb-YYMMDD_hhmm-minID-maxID.csv</code>.</li>
              <li>The <strong>Flashcard Reviewer</strong> draws from an internal representation of the data. You can reset/ export/ import the “bucket arrangement” as needed.</li>
              <li><strong>Clear IndexedDB</strong> if you want to remove all data entirely (be careful!).</li>
              <li>Toggle <strong>Dark Mode</strong> from the top-right button.</li>
            </ol>
            <h6>Notes</h6>
            <ul>
              <li>If you add single-column text posts, they will appear as “front = entire line, back = ''” (an empty string) if drawn in forward direction. The reversed direction is “'' → entire line.”</li>
              <li>We always remove exact duplicate lines from being stored (case-sensitive). The line includes everything up to the newline.</li>
              <li>The “DB Size” is an approximate summation of all stored lines in IndexedDB. It’s not an exact measure of on-disk usage, but it’s close enough for reference.</li>
            </ul>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

  </div> <!-- /container -->

  <!-- Bootstrap JS and dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-wpsYrgENSMwvWDnK+0hqyc+8zhu+uZdzsOCS8KQmS1b2y2lZjY0Chvh6e+GD44G"
          crossorigin="anonymous"></script>

  <script>
    /****************************************************
     *            INDEXEDDB + CSV UPLOAD LOGIC
     ****************************************************/
    const DB_NAME = 'myCsvDb';
    const DB_VERSION = 1;
    const STORE_NAME = 'records';
    let db = null;

    // We also keep local memory of allRecords for quick usage in the flashcard snippet
    // (so we don’t have to re-query IDB every time).
    let allRecords = []; // Each record = {id, text}

    // For the snippet’s Bucket logic:
    let state = {
      b1: {}, // { recordId: frequency }
      b2: {}, // { recordId: frequency }
      uniqueBucket1Count: 0,
      b1Prob: 0.33,
      b2Prob: 0.67,
      drawHistory: [] // last 5 draws
    };
    const historyLimit = 5;
    let lastDrawnId = null;
    let localBucketsKey = "flashcardBuckets_v1"; // localStorage key for bucket arrangement

    // On window load, open the DB and load any existing records into memory
    window.addEventListener('load', async () => {
      await openDatabase();
      await loadAllRecordsToMemory();
      updateDbSizeDisplay();
      loadDarkMode();
      updateProbabilities();
      populateBucketLists();
      populateHistoryList();
      updateDisplay();
      // get random Pantone color
      getRandomColor();

      // Also attach click to all buttons to change background color, just like the snippet
      const allButtons = document.querySelectorAll('button');
      allButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          getRandomColor();
        });
      });
    });

    async function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, {
              keyPath: 'id',
              autoIncrement: true
            });
            // Create an index on the text field to quickly check duplicates
            store.createIndex('textIndex', 'text', { unique: true });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };
        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    async function loadAllRecordsToMemory() {
      allRecords = [];
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.openCursor();
        request.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            allRecords.push({ id: cursor.value.id, text: cursor.value.text });
            cursor.continue();
          } else {
            resolve();
          }
        };
        request.onerror = (err) => reject(err);
      });
    }

    // Called after adding new records or clearing DB, etc.
    async function refreshData() {
      await loadAllRecordsToMemory();
      updateDbSizeDisplay();
      // The snippet’s “b2” ideally holds everything at first usage. If you want fresh
      // re-population, call resetBuckets() to force re-bucketing.
    }

    // Add lines to DB (removing duplicates). Returns count of inserted items.
    async function addLinesToDb(lines) {
      let addedCount = 0;
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const textIndex = store.index('textIndex');

      for (const line of lines) {
        if (!line.trim()) continue;
        // Check if this exact line already exists
        try {
          await new Promise((res, rej) => {
            const checkReq = textIndex.get(line);
            checkReq.onsuccess = (evt) => {
              if (checkReq.result) {
                // duplicate; skip
                res(null);
              } else {
                // insert
                const addReq = store.add({ text: line });
                addReq.onsuccess = () => {
                  addedCount++;
                  res(null);
                };
                addReq.onerror = (e) => rej(e);
              }
            };
            checkReq.onerror = (e) => rej(e);
          });
        } catch (e) {
          console.error(e);
        }
      }
      return addedCount;
    }

    // Handle "Upload CSV(s)" button
    async function handleFiles() {
      const fileInput = document.getElementById('csvFileInput');
      const files = fileInput.files;
      if (!files || files.length === 0) {
        alert("No CSV file selected.");
        return;
      }
      let totalInserted = 0;

      for (const file of files) {
        const text = await file.text();
        const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        // We assume each line is "some_front, some_back". We'll just store that full line as a text string.
        // We'll remove duplicates in IDB. 
        const inserted = await addLinesToDb(lines);
        totalInserted += inserted;
      }

      showToast(`Imported! ${totalInserted} new line(s) added to DB.`);
      await refreshData();
      // If you want to reset the snippet’s buckets each time you import, call resetBuckets() here. 
      // But we'll let you do it manually.
    }

    // Handle "Add Text Post" button
    async function addTextPost() {
      const textArea = document.getElementById('textPostInput');
      let rawText = textArea.value.trim();
      if (!rawText) {
        alert("No text entered.");
        return;
      }
      // Replace commas with underscores
      rawText = rawText.replace(/,/g, "_");
      // Format: "YYMMDD hh:mm:ss, text"
      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const min = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');

      const datePrefix = `${yy}${mm}${dd} ${hh}:${min}:${ss}`;
      const fullLine = `${datePrefix}, ${rawText}`;

      const added = await addLinesToDb([fullLine]);
      if (added > 0) {
        showToast("Text post added to DB!");
      } else {
        showToast("That exact line already exists in DB; skipping.");
      }
      textArea.value = "";
      await refreshData();
    }

    // Handle "Download All as CSV" button
    async function downloadAllRecords() {
      if (allRecords.length === 0) {
        alert("No records in DB to download.");
        return;
      }
      // Sort by ID ascending
      const sorted = [...allRecords].sort((a, b) => a.id - b.id);
      const minId = sorted[0].id;
      const maxId = sorted[sorted.length - 1].id;

      // Build CSV text
      // Each record's .text is a single line, containing the front/back or custom text
      // We'll just output that line exactly. 
      // If you need to ensure CSV escaping, do it here. For simplicity we assume no newlines.
      let csvOutput = "";
      for (const rec of sorted) {
        csvOutput += rec.text + "\n";
      }

      // Generate filename
      const now = new Date();
      const yy = String(now.getFullYear()).slice(-2);
      const mo = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const mi = String(now.getMinutes()).padStart(2, '0');

      const fileName = `indexedDb-${yy}${mo}${dd}_${hh}${mi}-${minId}-${maxId}.csv`;

      // Download
      const blob = new Blob([csvOutput], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
    }

    // Handle "Clear IndexedDB" button
    async function clearDatabase() {
      if (!confirm("Are you sure you want to clear ALL data in IndexedDB? This is irreversible.")) {
        return;
      }
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const clearReq = store.clear();
      clearReq.onsuccess = async () => {
        showToast("Database cleared!");
        await refreshData();
      };
      clearReq.onerror = (err) => {
        console.error(err);
      };
    }

    // Display approximate total size
    function updateDbSizeDisplay() {
      let totalBytes = 0;
      for (const rec of allRecords) {
        totalBytes += rec.text.length;
      }
      const span = document.getElementById("dbSizeSpan");
      span.textContent = `${totalBytes} bytes`;
    }

    /****************************************************
     *       FLASHCARD SNIPPET (ADAPTED)
     *  We'll repurpose the previously loaded "allRecords"
     *  as the data source. Because the original snippet
     *  doubled each line (front->back and back->front),
     *  we’ll do it on-the-fly in memory.
     ****************************************************/

    // We'll generate a separate array: allCards = [ { id, front, back }, ... ].
    // Because each DB record might have 1 or 2 columns. We'll parse them once.

    function buildAllCards() {
      const cards = [];
      let cardIdCounter = 0;
      for (const r of allRecords) {
        const parts = r.text.split(",");
        // minimal parse: we’ll take the first two elements as front/back
        const front = (parts[0] || "").trim();
        const back = (parts[1] || "").trim();
        // create front->back
        cards.push({ id: cardIdCounter++, origId: r.id, front, back });
        // create back->front
        cards.push({ id: cardIdCounter++, origId: r.id, front: back, back: front });
      }
      return cards;
    }

    // We’ll keep this in a variable for quick reference:
    let allCards = [];

    function drawCard() {
      if (allRecords.length === 0) {
        alert("No data in DB to draw from. Upload CSV or add text first.");
        return;
      }
      // Rebuild allCards so it’s up to date
      allCards = buildAllCards();

      // Hide the card's back if it was previously revealed
      document.getElementById("backTextContainer").style.display = "none";
      // Hide the Google/ChatGPT search buttons
      document.getElementById("googleSearchButtons").style.display = "none";

      // Weighted pick: b1 vs b2
      const rand = cryptoRand();
      let chosenBucket = (rand < state.b1Prob) ? "b1" : "b2";
      if (getTotalFreq(state[chosenBucket]) === 0) {
        // pick the other
        chosenBucket = (chosenBucket === "b1") ? "b2" : "b1";
      }
      if (getTotalFreq(state[chosenBucket]) === 0) {
        alert("No cards to draw from either bucket. Possibly you haven't assigned them yet or you already used them all.");
        return;
      }

      const selectedId = weightedPick(state[chosenBucket]);
      lastDrawnId = selectedId;

      // Add or increment to b1
      if (!(selectedId in state.b1)) {
        state.b1[selectedId] = 1;
        state.uniqueBucket1Count++;
      } else {
        state.b1[selectedId]++;
      }
      // Decrement in b2
      if (selectedId in state.b2) {
        state.b2[selectedId] = Math.max(0, state.b2[selectedId] - 1);
        if (state.b2[selectedId] === 0) {
          delete state.b2[selectedId];
        }
      }

      // Update UI
      saveBucketState();
      updateDisplay();
      populateBucketLists();

      // Display the chosen card
      const card = allCards.find(c => c.id === selectedId);
      if (!card) {
        alert("Something went wrong: card not found.");
        return;
      }
      currentFront = card.front;
      currentBack = card.back;

      const frontEl = document.getElementById("frontText");
      const backEl = document.getElementById("backText");
      frontEl.innerText = currentFront;
      backEl.innerText = currentBack;
      adjustFontSize(frontEl, currentFront);
      adjustFontSize(backEl, currentBack);

      addToHistory(selectedId);
      populateHistoryList();
    }

    function revealAnswer() {
      document.getElementById("backTextContainer").style.display = "block";
      // Show the Google/ChatGPT search buttons
      document.getElementById("googleSearchButtons").style.display = "block";
    }

    function undoLastDraw() {
      if (lastDrawnId == null) {
        alert("No recent draw to undo!");
        return;
      }
      if (!(lastDrawnId in state.b1)) {
        alert("Cannot undo: card not found in Bucket 1.");
        return;
      }
      state.b1[lastDrawnId]--;
      if (state.b1[lastDrawnId] <= 0) {
        delete state.b1[lastDrawnId];
        state.uniqueBucket1Count--;
      }
      if (lastDrawnId in state.b2) {
        state.b2[lastDrawnId]++;
      } else {
        state.b2[lastDrawnId] = 1;
      }

      // Remove from drawHistory’s front
      state.drawHistory.shift();

      lastDrawnId = null;
      saveBucketState();
      updateDisplay();
      populateBucketLists();
      populateHistoryList();
      showToast("Last draw undone.");
    }

    // Searching
    let currentFront = "";
    let currentBack = "";

    function googleSearchFront() {
      if (!currentFront) return;
      window.open("https://www.google.com/search?q=" + encodeURIComponent(currentFront), "_blank");
    }
    function googleSearchBack() {
      if (!currentBack) return;
      window.open("https://www.google.com/search?q=" + encodeURIComponent(currentBack), "_blank");
    }
    function chatGPTSearchFront() {
      if (!currentFront) return;
      window.open("https://chat.openai.com/?q=" + encodeURIComponent(currentFront), "_blank");
    }
    function chatGPTSearchBack() {
      if (!currentBack) return;
      window.open("https://chat.openai.com/?q=" + encodeURIComponent(currentBack), "_blank");
    }
    function jishoSearchFront() {
      if (!currentFront) return;
      window.open("https://jisho.org/search/" + encodeURIComponent(currentFront), "_blank");
    }
    function jishoSearchBack() {
      if (!currentBack) return;
      window.open("https://jisho.org/search/" + encodeURIComponent(currentBack), "_blank");
    }

    // Font size
    function adjustFontSize(element, text) {
      const length = text.length;
      if (length <= 3) {
        element.style.fontSize = "3rem";
      } else if (length <= 10) {
        element.style.fontSize = "2.5rem";
      } else if (length <= 30) {
        element.style.fontSize = "2rem";
      } else {
        element.style.fontSize = "1.25rem";
      }
    }

    // History
    function addToHistory(cardId) {
      const ts = new Date().toLocaleString();
      // find the card
      const card = allCards.find(c => c.id === cardId);
      if (!card) return;
      const entry = {
        id: cardId,
        front: card.front,
        back: card.back,
        timestamp: ts
      };
      state.drawHistory.unshift(entry);
      while (state.drawHistory.length > historyLimit) {
        state.drawHistory.pop();
      }
    }
    function populateHistoryList() {
      const historyList = document.getElementById("historyList");
      historyList.innerHTML = "";
      for (let h of state.drawHistory) {
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.innerHTML = `<strong>${h.timestamp}:</strong> ${h.front} → ${h.back}`;
        historyList.appendChild(li);
      }
    }

    // Bucket lists
    function populateBucketLists() {
      const b1List = document.getElementById("bucket1List");
      const b2List = document.getElementById("bucket2List");
      b1List.innerHTML = "";
      b2List.innerHTML = "";

      for (let cardId in state.b1) {
        const freq = state.b1[cardId];
        // find the card
        const card = allCards.find(c => c.id === Number(cardId));
        if (!card) continue;
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.textContent = `${card.front} → ${card.back} (Freq: ${freq})`;
        b1List.appendChild(li);
      }
      for (let cardId in state.b2) {
        const freq = state.b2[cardId];
        const card = allCards.find(c => c.id === Number(cardId));
        if (!card) continue;
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.textContent = `${card.front} → ${card.back} (Freq: ${freq})`;
        b2List.appendChild(li);
      }

      document.getElementById("bucket1Freq").innerText = getTotalFreq(state.b1);
      document.getElementById("bucket2Freq").innerText = getTotalFreq(state.b2);
    }

    // Gauges & display
    function updateDisplay() {
      // the “totalCards” means total of the doubled allCards
      // but let's interpret “uniqueBucket1Count” vs. the entire 2x set:
      allCards = buildAllCards();
      const totalCards = allCards.length; // 2x real records
      const fraction = (state.uniqueBucket1Count / totalCards) * 100;
      const fraction2 = 100 - fraction;

      const r1Gauge = document.getElementById("review1Gauge");
      const r1Text = document.getElementById("review1Text");
      const r2Gauge = document.getElementById("review2Gauge");
      const r2Text = document.getElementById("review2Text");

      r1Gauge.value = fraction.toFixed(2);
      r1Text.innerText = fraction.toFixed(2) + "%";
      r2Gauge.value = fraction2.toFixed(2);
      r2Text.innerText = fraction2.toFixed(2) + "%";
    }

    // Probability slider
    function updateProbabilities() {
      const sliderVal = parseInt(document.getElementById("probSlider").value);
      state.b1Prob = sliderVal / 100;
      state.b2Prob = 1 - state.b1Prob;
      document.getElementById("probBucket1").innerText = (state.b1Prob * 100).toFixed(0) + "%";
      document.getElementById("probBucket2").innerText = (state.b2Prob * 100).toFixed(0) + "%";
      saveBucketState();
    }

    // Weighted pick
    function weightedPick(bucketObj) {
      const entries = Object.entries(bucketObj);
      const total = entries.reduce((acc, [_, freq]) => acc + freq, 0);
      const randVal = Math.floor(cryptoRand() * total);
      let sum = 0;
      for (let [key, freq] of entries) {
        sum += freq;
        if (randVal < sum) {
          return Number(key);
        }
      }
      return Number(entries[entries.length - 1][0]);
    }
    function getTotalFreq(bucket) {
      return Object.values(bucket).reduce((acc, val) => acc + val, 0);
    }
    function cryptoRand() {
      const arr = new Uint32Array(1);
      window.crypto.getRandomValues(arr);
      return arr[0] / (0xffffffff + 1);
    }

    // Export/Import/Reset bucket arrangement
    function exportState() {
      const str = JSON.stringify(state, null, 2);
      const blob = new Blob([str], { type: "application/json" });
      const now = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `flashcard-buckets-${now}.json`;

      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();

      showToast("Bucket state exported successfully.");
    }
    function importState() {
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json,application/json";
      fileInput.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = event => {
            try {
              const imported = JSON.parse(event.target.result);
              state = { ...state, ...imported };
              saveBucketState();
              updateDisplay();
              populateBucketLists();
              populateHistoryList();
              showToast("Bucket state imported successfully.");
            } catch (err) {
              alert("Invalid JSON file.");
            }
          };
          reader.readAsText(file);
        }
      };
      fileInput.click();
    }
    function resetBuckets() {
      if (!confirm("Reset bucket arrangement? This won’t erase your data in IndexedDB, just the review progress.")) return;
      state = {
        b1: {},
        b2: {},
        uniqueBucket1Count: 0,
        b1Prob: state.b1Prob,
        b2Prob: state.b2Prob,
        drawHistory: []
      };
      // By default, place all card IDs into b2 with freq=1:
      allCards = buildAllCards();
      for (let c of allCards) {
        state.b2[c.id] = 1;
      }
      saveBucketState();
      updateDisplay();
      populateBucketLists();
      populateHistoryList();
      showToast("Buckets reset. All items are back in Bucket2.");
    }

    function saveBucketState() {
      localStorage.setItem(localBucketsKey, JSON.stringify(state));
    }
    function loadBucketState() {
      const raw = localStorage.getItem(localBucketsKey);
      if (raw) {
        try {
          const parsed = JSON.parse(raw);
          state = { ...state, ...parsed };
        } catch(e) {
          console.warn("Failed to parse saved bucket state, ignoring.");
        }
      }
    }
    // Call load once at script load
    loadBucketState();

    /****************************************************
     *                UTIL / MISC
     ****************************************************/
    function showToast(msg) {
      const toastContainer = document.getElementById("toastContainer");
      const toastEl = document.createElement("div");
      toastEl.className = "toast align-items-center text-bg-primary border-0";
      toastEl.setAttribute("role", "alert");
      toastEl.setAttribute("aria-live", "assertive");
      toastEl.setAttribute("aria-atomic", "true");
      toastEl.style.minWidth = "200px";

      toastEl.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">${msg}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto"
                  data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      `;
      toastContainer.appendChild(toastEl);
      const bsToast = new bootstrap.Toast(toastEl);
      bsToast.show();
      toastEl.addEventListener("hidden.bs.toast", () => {
        toastContainer.removeChild(toastEl);
      });
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
      localStorage.setItem("flashcardsDarkMode", document.body.classList.contains("dark-mode"));
    }

    function loadDarkMode() {
      const isDark = localStorage.getItem("flashcardsDarkMode") === "true";
      if (isDark) {
        document.body.classList.add("dark-mode");
      }
    }

    // random Pantone color usage
    async function getRandomColor() {
      try {
        const response = await fetch("pantone-colors.json");
        if (!response.ok) throw new Error("No pantone-colors.json found");
        const pantoneData = await response.json();
        const { names, values } = pantoneData;
        if (!names || !values || names.length !== values.length) {
          throw new Error("Invalid pantone-colors.json format");
        }
        const arr = new Uint32Array(1);
        window.crypto.getRandomValues(arr);
        const rand = arr[0] / (0xFFFFFFFF + 1);
        const randomIndex = Math.floor(rand * names.length);
        document.body.style.backgroundColor = values[randomIndex];
        const colorDisplay = document.getElementById("pantoneColorDisplay");
        if (colorDisplay) {
          colorDisplay.textContent = `${names[randomIndex]} (${values[randomIndex]})`;
        }
      } catch (error) {
        // fallback
        document.body.style.backgroundColor = "#ffffff";
      }
    }
  </script>
</body>
</html>
