<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random CSV Redirect (Weighted + Nested CSV + Proper Quoted CSV Parsing)</title>
  <!-- 
    Added Bootstrap CSS for a simple progress bar styling. 
    Remove/adjust if you already have your own setup.
  -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  >
</head>
<body>

<!-- 
  A container for the progress bar animation...
  We'll fill or remove this dynamically in code.
-->
<div id="progress-container" style="margin:10px;"></div>

<script>
/**
 * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
 */
function getSecureRandomNumber() {
  const array = new Uint32Array(1);
  window.crypto.getRandomValues(array);
  return array[0] / (0xFFFFFFFF + 1);
}

/**
 * Strips leading/trailing quotes from a string. Also trims whitespace.
 * Example: "\"https://www.youtube.com\"" => "https://www.youtube.com"
 */
function cleanCell(cell) {
  cell = cell.trim();
  // Remove leading/trailing quotes (single or double)
  cell = cell.replace(/^["']+|["']+$/g, '');
  return cell;
}

/**
 * Parses a single CSV line into an array of cell strings, 
 * respecting double quotes so commas inside quotes are not split.
 *
 * Example line:
 *   link,1,"https://example.com/some?query=1,2,3"
 * Should parse to:
 *   ["link", "1", "https://example.com/some?query=1,2,3"]
 *
 * This handles escaped quotes inside a quoted cell by doubling them: ""
 */
function parseCsvLine(line) {
  const result = [];
  let curCell = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const c = line[i];

    if (c === '"') {
      // Look ahead for another quote => escaped double-quote
      if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
        // Add a literal quote to the current cell
        curCell += '"';
        i++;
      } else {
        // Toggle the inQuotes flag
        inQuotes = !inQuotes;
      }
    }
    else if (c === ',' && !inQuotes) {
      // Split point
      result.push(curCell);
      curCell = '';
    }
    else {
      // Normal character
      curCell += c;
    }
  }

  // Push the last cell
  result.push(curCell);

  return result;
}

/**
 * Fetch and parse a CSV file, returning an array of rows.
 * Each row is an array of "cleaned" cells, respecting quoted fields.
 *
 * @param {string} csvFilename The CSV filename to fetch (relative path)
 * @returns {Promise<string[][]>} The parsed CSV rows
 */
async function fetchCSV(csvFilename) {
  console.log(`Attempting to fetch CSV: ${csvFilename}`);

  try {
    const response = await fetch(csvFilename);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV file: ${response.status} ${response.statusText}`);
    }
    const csvText = await response.text();

    // Split text into lines, filtering out blank lines
    const lines = csvText
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log('Raw lines:', lines);

    // For each line, parse properly, then clean each cell
    const rows = lines.map(line => {
      const parsedCells = parseCsvLine(line);
      return parsedCells.map(cell => cleanCell(cell));
    });

    console.log('Parsed rows (with cleaned cells):', rows);
    return rows;
  } catch (error) {
    throw new Error('Error fetching CSV: ' + error.message);
  }
}

/**
 * Picks one row based on integer weight in the second cell of each row.
 *   row[0] = type
 *   row[1] = weight (integer >= 1)
 *   row[2..] = other data
 *
 * If totalWeight <= 0 (all invalid or zero), we fall back to uniform random.
 *
 * @param {string[][]} rows
 * @returns {string[]} The selected row
 */
function pickRowByWeight(rows) {
  const weightedRows = rows.map(r => {
    let w = parseInt(r[1], 10);
    // Default weight to 1 if it's invalid or < 1
    if (isNaN(w) || w < 1) {
      w = 1;
    }
    return { row: r, weight: w };
  });

  let totalWeight = 0;
  for (const wr of weightedRows) {
    totalWeight += wr.weight;
  }

  // If totalWeight is 0, fall back to uniform random
  if (totalWeight <= 0) {
    console.warn('Total weight is zero or invalid. Falling back to uniform random choice.');
    const randomIndex = Math.floor(getSecureRandomNumber() * rows.length);
    return rows[randomIndex];
  }

  // Generate a random number in [0, totalWeight)
  let rand = getSecureRandomNumber() * totalWeight;

  // Find which row corresponds to this random value
  for (const wr of weightedRows) {
    if (rand < wr.weight) {
      return wr.row;
    }
    rand -= wr.weight;
  }

  // Fallback (due to floating-point rounding, etc.)
  return weightedRows[weightedRows.length - 1].row;
}

/**
 * Stores redirect analytics (row type, final URL, timestamp) in localStorage.
 * @param {string} rowType The type of the row (e.g., 'link', 'git-specific', etc.)
 * @param {string} url The final URL the user is being redirected to
 */
function storeRedirectAnalytics(rowType, url) {
  try {
    let analyticsData = localStorage.getItem('redirectAnalytics');
    if (!analyticsData) {
      analyticsData = [];
    } else {
      analyticsData = JSON.parse(analyticsData);
    }

    analyticsData.push({
      rowType: rowType,
      url: url,
      timestamp: new Date().toISOString()
    });

    localStorage.setItem('redirectAnalytics', JSON.stringify(analyticsData));
  } catch (err) {
    // If localStorage is not available or any other error occurs, silently fail
    console.error('Failed to store redirect analytics:', err);
  }
}

/**
 * (ORIGINAL) Processes rows by picking one (weighted) and acting according to its type.
 * This function remains intact, but we'll no longer call it directly from main().
 * We keep it so existing functionality is not removed.
 *
 * @param {string[][]} rows Parsed CSV rows
 * @param {number} recursionDepth Avoid infinite recursion on nested CSV references
 */
async function processRows(rows, recursionDepth = 0) {
  // Basic safeguard against unexpected infinite loops
  if (recursionDepth > 20) {
    document.body.textContent = 'Error: Exceeded maximum CSV nesting depth.';
    return;
  }

  if (!rows.length) {
    document.body.textContent = 'CSV is empty or could not be parsed.';
    return;
  }

  // Weighted selection
  const selectedRow = pickRowByWeight(rows);

  console.log('All rows:', rows);
  console.log('Selected row:', selectedRow);

  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    // Format: link,<weight>,<url>
    const url = selectedRow[2];
    console.log('Redirecting to link:', url);

    // Store analytics
    storeRedirectAnalytics(rowType, url);

    window.location.href = url;
  }
  else if (rowType === 'git-specific') {
    // Format: git-specific,<weight>,username=xxxx,repository=yyyy,issueNumbers=1_2_3
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersStr = selectedRow[4].split('=')[1];
    const issueNumbersArr = issueNumbersStr.split('_');

    const randIdx = Math.floor(getSecureRandomNumber() * issueNumbersArr.length);
    const chosenIssue = issueNumbersArr[randIdx];
    const finalUrl = `https://github.com/${username}/${repository}/issues/${chosenIssue}`;

    console.log('Redirecting to git-specific issue:', finalUrl);

    // Store analytics
    storeRedirectAnalytics(rowType, finalUrl);

    window.location.href = finalUrl;
  }
  else if (rowType === 'git-range') {
    // Format: git-range,<weight>,username=xxxx,repository=yyyy,issueNumbers=min_max
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const rangeStr = selectedRow[4].split('=')[1];
    const [minStr, maxStr] = rangeStr.split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);

    if (isNaN(min) || isNaN(max)) {
      document.body.textContent = 'Invalid range in "git-range" row.';
      return;
    }

    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    const finalUrl = `https://github.com/${username}/${repository}/issues/${randomVal}`;

    console.log('Redirecting to git-range issue:', finalUrl);

    // Store analytics
    storeRedirectAnalytics(rowType, finalUrl);

    window.location.href = finalUrl;
  }
  else if (rowType === 'csv') {
    // Format: csv,<weight>,<another-file.csv>
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      document.body.textContent = 'CSV type found but no filename specified.';
      return;
    }
    console.log('Nested CSV found. Fetching:', nestedCsv);

    try {
      const nestedRows = await fetchCSV(nestedCsv);
      await processRows(nestedRows, recursionDepth + 1);
    } catch (error) {
      document.body.textContent = error.message;
    }
  }
  else {
    document.body.textContent = 'Unknown row type: ' + rowType;
  }
}

/* 
  NEW FUNCTION:
  ---------------------------------------------------------------
  We need to get the final redirect URL from a single weighted pick 
  (including potential recursion for 'csv' row types) WITHOUT actually 
  redirecting. We'll adapt the logic from processRows().
*/
async function getFinalUrlFromRows(rows, recursionDepth = 0) {
  if (recursionDepth > 20) {
    throw new Error('Error: Exceeded maximum CSV nesting depth.');
  }

  if (!rows.length) {
    throw new Error('CSV is empty or could not be parsed.');
  }

  const selectedRow = pickRowByWeight(rows);
  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    // Format: link,<weight>,<url>
    const url = selectedRow[2];
    return { rowType, url };
  }
  else if (rowType === 'git-specific') {
    // Format: git-specific,<weight>,username=xxxx,repository=yyyy,issueNumbers=1_2_3
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersStr = selectedRow[4].split('=')[1];
    const issueNumbersArr = issueNumbersStr.split('_');

    const randIdx = Math.floor(getSecureRandomNumber() * issueNumbersArr.length);
    const chosenIssue = issueNumbersArr[randIdx];
    const finalUrl = `https://github.com/${username}/${repository}/issues/${chosenIssue}`;

    return { rowType, url: finalUrl };
  }
  else if (rowType === 'git-range') {
    // Format: git-range,<weight>,username=xxxx,repository=yyyy,issueNumbers=min_max
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const rangeStr = selectedRow[4].split('=')[1];
    const [minStr, maxStr] = rangeStr.split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);

    if (isNaN(min) || isNaN(max)) {
      throw new Error('Invalid range in "git-range" row.');
    }

    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    const finalUrl = `https://github.com/${username}/${repository}/issues/${randomVal}`;

    return { rowType, url: finalUrl };
  }
  else if (rowType === 'csv') {
    // Format: csv,<weight>,<another-file.csv>
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      throw new Error('CSV type found but no filename specified.');
    }

    // Fetch nested CSV and pick from it (recursively)
    const nestedRows = await fetchCSV(nestedCsv);
    return await getFinalUrlFromRows(nestedRows, recursionDepth + 1);
  }
  else {
    throw new Error('Unknown row type: ' + rowType);
  }
}

/* 
  HELPER FUNCTIONS FOR "SIMILAR" URL DETECTION
  ---------------------------------------------------------------
  We'll define "similar" based on how many characters match 
  from the beginning (common prefix). If the ratio of that 
  common prefix to the shorter URL’s length is at least 0.7 (70%), 
  we'll call them "similar." Adjust as needed.
*/

/**
 * Returns the length of the common prefix between str1 and str2.
 */
function getCommonPrefixLength(str1, str2) {
  const len = Math.min(str1.length, str2.length);
  let i = 0;
  while (i < len && str1[i] === str2[i]) {
    i++;
  }
  return i;
}

/**
 * Decides if two URLs are "similar" if their common prefix
 * ratio is >= 70% of the shorter string’s length.
 */
function isSimilar(url1, url2) {
  if (url1 === url2) return true; // exact match is automatically "similar"
  const prefixLen = getCommonPrefixLength(url1, url2);
  const minLen = Math.min(url1.length, url2.length);
  const ratio = prefixLen / minLen; 
  return ratio >= 0.7;
}

/* 
  NEW FUNCTION (MODIFIED):
  ---------------------------------------------------------------
  Takes the final URLs array (length 100) and tries to space them out
  so that not only exact duplicates but also "similar" items 
  (matching on early portion of the URLs) are not adjacent.
*/
function intersperseUrls(picks) {
  /*
    picks is an array of objects: [ {rowType, url}, {rowType, url}, ... ]

    We want to minimize consecutive *exact duplicates* or *similar* items.
    We'll adapt a naive approach: each time we pick an item 
    that is not "similar" to the last placed item. 
    We'll still use a frequency-based approach for overall distribution.
  */

  // Tally exact frequencies by URL
  const freqMap = {};
  picks.forEach(item => {
    freqMap[item.url] = (freqMap[item.url] || 0) + 1;
  });

  // Create an array of { url, rowType, count }
  const freqArr = [];
  for (const url in freqMap) {
    const rowType = picks.find(x => x.url === url).rowType;
    freqArr.push({
      url,
      rowType,
      count: freqMap[url]
    });
  }

  // Sort descending by count
  freqArr.sort((a,b) => b.count - a.count);

  const result = [];
  let prevUrl = null;

  while (true) {
    // Sort again each iteration so the largest count is first
    freqArr.sort((a,b) => b.count - a.count);

    // Remove any that have zero count
    while (freqArr.length > 0 && freqArr[freqArr.length - 1].count <= 0) {
      freqArr.pop();
    }

    if (freqArr.length === 0) {
      break;
    }

    // Attempt to find the first entry NOT "similar" to prevUrl
    let idxToPick = -1;
    for (let i = 0; i < freqArr.length; i++) {
      const candidate = freqArr[i];
      // If there's no prevUrl, it's always safe
      if (!prevUrl) {
        idxToPick = i;
        break;
      }
      if (!isSimilar(candidate.url, prevUrl)) {
        idxToPick = i;
        break;
      }
    }

    // If all are "similar" to prevUrl, pick the first anyway (no choice)
    if (idxToPick === -1) {
      idxToPick = 0;
    }

    // Decrement count, push to result
    const chosen = freqArr[idxToPick];
    chosen.count -= 1;
    result.push({ rowType: chosen.rowType, url: chosen.url });
    prevUrl = chosen.url;
  }

  // Return the final interspersed array
  return result;
}

/* 
  NEW FUNCTIONS: Show/hide progress bar 
*/
function showProgressBar(total) {
  const container = document.getElementById('progress-container');
  container.innerHTML = `
    <div class="progress" style="height: 25px;">
      <div
        class="progress-bar progress-bar-striped progress-bar-animated"
        role="progressbar"
        style="width: 0%;"
        aria-valuenow="0"
        aria-valuemin="0"
        aria-valuemax="${total}"
        id="generation-progress-bar"
      >
        0%
      </div>
    </div>
    <p id="progress-label" style="margin-top:5px;">Generating 0 of ${total}...</p>
  `;
}

function updateProgressBar(current, total) {
  const bar = document.getElementById('generation-progress-bar');
  const label = document.getElementById('progress-label');
  if (!bar || !label) return;

  const percent = Math.floor((current / total) * 100);
  bar.style.width = percent + '%';
  bar.setAttribute('aria-valuenow', current);
  bar.textContent = `${percent}%`;
  label.textContent = `Generating ${current} of ${total}...`;
}

function hideProgressBar() {
  const container = document.getElementById('progress-container');
  container.innerHTML = '';
}

/*
  NEW FUNCTION:
  ---------------------------------------------------------------
  Generate 100 final URLs, intersperse them, store them in localStorage
  along with their rowType. We also display a simple progress bar 
  while generating.
*/
async function generateQueue(rows) {
  const total = 100;
  showProgressBar(total);

  const picks = [];
  for (let i = 1; i <= total; i++) {
    // We do what 'processRows' would do, but just store the final URL instead
    const finalObj = await getFinalUrlFromRows(rows, 0);
    picks.push(finalObj);
    updateProgressBar(i, total);
  }

  hideProgressBar();

  // Interspersing (reduce consecutive duplicates and "similar" items)
  const interspersed = intersperseUrls(picks);

  // Store in localStorage with timestamp
  const payload = {
    createdAt: Date.now(), // ms
    items: interspersed
  };
  localStorage.setItem('redirectQueue', JSON.stringify(payload));

  return interspersed;
}

/*
  NEW FUNCTION:
  ---------------------------------------------------------------
  Pops the first item from localStorage queue (if it exists)
  and returns it. If the queue is empty or expired, return null.
*/
function popFromQueue() {
  const raw = localStorage.getItem('redirectQueue');
  if (!raw) return null;

  let payload = null;
  try {
    payload = JSON.parse(raw);
  } catch (err) {
    // Corrupted data
    return null;
  }
  if (!payload || !payload.items || !Array.isArray(payload.items)) {
    return null;
  }

  const createdAt = payload.createdAt || 0;
  const now = Date.now();
  const oneHour = 3600000;

  if (now - createdAt > oneHour) {
    // Expired
    return null;
  }

  if (payload.items.length === 0) {
    // Already empty
    return null;
  }

  // Pop the first item
  const popped = payload.items.shift();
  // Store updated array back
  localStorage.setItem('redirectQueue', JSON.stringify(payload));

  return popped;
}

/*
  NEW FUNCTION:
  ---------------------------------------------------------------
  We'll do the final redirect with the popped item.
  We'll also store analytics if it exists.
*/
function doRedirect(finalObj) {
  if (!finalObj) {
    document.body.textContent = 'Error: No item available for redirect.';
    return;
  }

  const { rowType, url } = finalObj;
  console.log('Redirecting with rowType/url:', rowType, url);

  // Store analytics
  storeRedirectAnalytics(rowType, url);

  window.location.href = url;
}

/**
 * Main entry point:
 * 1. Read "target" param from URL (?target=filename.csv)
 * 2. Attempt to pop from localStorage queue
 * 3. If queue is invalid/expired/empty, fetch CSV, parse, generate new queue
 * 4. Pop from queue, redirect
 */
async function main() {
  const urlParams = new URLSearchParams(window.location.search);
  const target = urlParams.get('target');

  if (!target) {
    document.body.textContent = 'No "target" parameter found. Use ?target=filename.csv';
    return;
  }

  // Try popping from existing queue
  let poppedItem = popFromQueue();
  if (poppedItem) {
    // If we got something, redirect with it
    doRedirect(poppedItem);
    return;
  }

  // If we get here, no valid queue or item is available
  // => fetch and parse CSV, generate a new queue
  try {
    const rows = await fetchCSV(target);

    // Find all valid (non-null) second-column integer values
    const nonNullValues = rows
      .map(r => (r[1] !== 'null' ? parseInt(r[1], 10) : NaN))
      .filter(val => !isNaN(val));

    // If we have any valid numbers at all, proceed
    if (nonNullValues.length > 0) {
      const minVal = Math.min(...nonNullValues);
      const maxVal = Math.max(...nonNullValues);

      // Assign random values between minVal and maxVal (inclusive) where second column is "null"
      for (let i = 0; i < rows.length; i++) {
        if (rows[i][1] === 'null') {
          const randomVal = Math.floor(getSecureRandomNumber() * (maxVal - minVal + 1)) + minVal;
          rows[i][1] = String(randomVal);
        }
      }
    }

    // Now generate a new queue of 100 picks
    await generateQueue(rows);
    // Pop from newly generated queue
    poppedItem = popFromQueue();

    // Redirect
    if (poppedItem) {
      doRedirect(poppedItem);
    } else {
      document.body.textContent = 'Error: failed to generate queue or pop an item.';
    }

  } catch (error) {
    document.body.textContent = 'Failed to process CSV: ' + error.message;
  }
}

window.onload = main;
</script>

<!-- 
  Optionally include Bootstrap JS if you need it for other components. 
  (For the progress bar animations, it's not strictly required.)
-->
<script
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
></script>

</body>
</html>
