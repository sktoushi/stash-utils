<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random CSV Redirect (Weighted + Nested CSV + Proper Quoted CSV Parsing)</title>
</head>
<body>
<script>
let configValues = {};
async function loadConfig() {
  if (Object.keys(configValues).length) return configValues;
  try {
    const resp = await fetch('config/values.json');
    if (resp.ok) {
      configValues = await resp.json();
    }
  } catch (err) {
    console.error('Failed to load config:', err);
  }
  return configValues;
}
/** Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive). */
function getSecureRandomNumber() {
  const array = new Uint32Array(1);
  window.crypto.getRandomValues(array);
  return array[0] / (0xFFFFFFFF + 1);
}
/** Strips leading/trailing quotes and trims whitespace. */
function cleanCell(cell) {
  cell = cell.trim();
  cell = cell.replace(/^["']+|["']+$/g, '');
  return cell;
}
/** CSV line parser that respects quoted commas and escaped quotes. */
function parseCsvLine(line) {
  const result = [];
  let curCell = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') {
      if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
        curCell += '"'; i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (c === ',' && !inQuotes) {
      result.push(curCell); curCell = '';
    } else {
      curCell += c;
    }
  }
  result.push(curCell);
  return result;
}
/** Fisherâ€“Yates shuffle (secure RNG). */
function shuffle(array) {
  let currentIndex = array.length;
  while (currentIndex !== 0) {
    const randomIndex = Math.floor(getSecureRandomNumber() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }
  return array;
}
function applyConfigPlaceholders(rows) {
  const re = /\{([^}]+)}/g;
  return rows.map(row => row.map(cell =>
    cell.replace(re, (m, p1) =>
      Object.prototype.hasOwnProperty.call(configValues, p1) ? configValues[p1] : m
    )
  ));
}
/** Fetch & parse CSV, return array-of-rows. */
async function fetchCSV(csvFilename) {
  console.log(`Attempting to fetch CSV: ${csvFilename}`);
  await loadConfig();
  try {
    const response = await fetch(csvFilename);
    if (!response.ok) throw new Error(`Failed to fetch CSV file: ${response.status} ${response.statusText}`);
    const csvText = await response.text();
    const lines = csvText.split('\n').map(l => l.trim()).filter(l => l.length);
    let rows = lines.map(line => parseCsvLine(line).map(cleanCell));
    rows = applyConfigPlaceholders(rows);
    shuffle(rows);
    return rows;
  } catch (error) {
    throw new Error('Error fetching CSV: ' + error.message);
  }
}
/** Weighted row picker (weight in column 1). */
function pickRowByWeight(rows) {
  const weightedRows = rows.map(r => {
    let w = parseInt(r[1], 10);
    if (isNaN(w) || w < 1) w = 1;
    return { row: r, weight: w };
  });
  let totalWeight = weightedRows.reduce((acc, wr) => acc + wr.weight, 0);
  if (totalWeight <= 0) {
    const randomIndex = Math.floor(getSecureRandomNumber() * rows.length);
    return rows[randomIndex];
  }
  let rand = getSecureRandomNumber() * totalWeight;
  for (const wr of weightedRows) {
    if (rand < wr.weight) return wr.row;
    rand -= wr.weight;
  }
  return weightedRows[weightedRows.length - 1].row;
}
/** Core processor */
async function processRows(rows, recursionDepth = 0) {
  if (recursionDepth > 2000) { document.body.textContent = 'Error: Exceeded maximum CSV nesting depth.'; return; }
  if (!rows.length) { document.body.textContent = 'CSV is empty or could not be parsed.'; return; }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ†• AUTO-WEIGHT PATCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  for (const r of rows) {
    if (r[0].trim() === 'csv' && parseInt(r[1], 10) === 0) {
      try {
        const nested = await fetchCSV(r[2]);          // fetch once
        r[1] = nested.length.toString();              // weight = inner row count
      } catch (err) {
        console.error('Auto-weight failed:', err);
        r[1] = '1';                                   // graceful fallback
      }
    }
  }
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ END PATCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  const selectedRow = pickRowByWeight(rows);
  console.log('All rows:', rows);
  console.log('Selected row:', selectedRow);
  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    window.location.href = selectedRow[2];
  } else if (rowType === 'git-specific') {
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersArr = selectedRow[4].split('=')[1].split('_');
    const chosenIssue = issueNumbersArr[Math.floor(getSecureRandomNumber() * issueNumbersArr.length)];
    window.location.href = `https://github.com/${username}/${repository}/issues/${chosenIssue}`;
  } else if (rowType === 'git-range') {
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const [min, max] = selectedRow[4].split('=')[1].split('_').map(s => parseInt(s, 10));
    if (isNaN(min) || isNaN(max)) { document.body.textContent = 'Invalid range in "git-range" row.'; return; }
    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    window.location.href = `https://github.com/${username}/${repository}/issues/${randomVal}`;
  } else if (rowType === 'csv') {
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) { document.body.textContent = 'CSV type found but no filename specified.'; return; }
    try {
      const nestedRows = await fetchCSV(nestedCsv);
      await processRows(nestedRows, recursionDepth + 1);
    } catch (error) {
      document.body.textContent = error.message;
    }
  } else {
    document.body.textContent = 'Unknown row type: ' + rowType;
  }
}
/** Main entry */
async function main() {
  await loadConfig();
  const urlParams = new URLSearchParams(window.location.search);
  const target = urlParams.get('target');
  if (!target) { document.body.textContent = 'No "target" parameter found. Use ?target=filename.csv'; return; }

  try {
    const rows = await fetchCSV(target);
    const nonNull = rows.map(r => (r[1] !== 'null' ? parseInt(r[1], 10) : NaN)).filter(v => !isNaN(v));
    if (nonNull.length) {
      const minVal = Math.min(...nonNull), maxVal = Math.max(...nonNull);
      for (let i = 0; i < rows.length; i++) {
        if (rows[i][1] === 'null') rows[i][1] = String(Math.floor(getSecureRandomNumber() * (maxVal - minVal + 1)) + minVal);
      }
    }
    await processRows(rows, 0);
  } catch (error) {
    document.body.textContent = 'Failed to process CSV: ' + error.message;
  }
}
window.onload = main;
</script>
</body>
</html>
