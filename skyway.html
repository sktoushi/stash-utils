<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Random CSV Redirect (Weighted + Nested CSV + Proper Quoted CSV Parsing)</title>
  <!-- Minimal Bootstrap (for progress bar styling). Feel free to adjust version if needed. -->
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  />
</head>
<body>
<div id="progress-container" class="container" style="display: none; margin-top: 50px;">
  <div class="row">
    <div class="col-12">
      <h3>Generating Redirects...</h3>
      <div class="progress">
        <div
          id="progress-bar"
          class="progress-bar"
          role="progressbar"
          style="width: 0%;"
          aria-valuenow="0"
          aria-valuemin="0"
          aria-valuemax="100"
        >
          0%
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/**
 * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
 */
function getSecureRandomNumber() {
  const array = new Uint32Array(1);
  window.crypto.getRandomValues(array);
  return array[0] / (0xFFFFFFFF + 1);
}

/**
 * Strips leading/trailing quotes from a string. Also trims whitespace.
 * Example: "\"https://www.youtube.com\"" => "https://www.youtube.com"
 */
function cleanCell(cell) {
  cell = cell.trim();
  // Remove leading/trailing quotes (single or double)
  cell = cell.replace(/^["']+|["']+$/g, '');
  return cell;
}

/**
 * Parses a single CSV line into an array of cell strings, 
 * respecting double quotes so commas inside quotes are not split.
 *
 * Example line:
 *   link,1,"https://example.com/some?query=1,2,3"
 * Should parse to:
 *   ["link", "1", "https://example.com/some?query=1,2,3"]
 *
 * This handles escaped quotes inside a quoted cell by doubling them: ""
 */
function parseCsvLine(line) {
  const result = [];
  let curCell = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const c = line[i];

    if (c === '"') {
      // Look ahead for another quote => escaped double-quote
      if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
        // Add a literal quote to the current cell
        curCell += '"';
        i++;
      } else {
        // Toggle the inQuotes flag
        inQuotes = !inQuotes;
      }
    }
    else if (c === ',' && !inQuotes) {
      // Split point
      result.push(curCell);
      curCell = '';
    }
    else {
      // Normal character
      curCell += c;
    }
  }

  // Push the last cell
  result.push(curCell);

  return result;
}

/**
 * Fetch and parse a CSV file, returning an array of rows.
 * Each row is an array of "cleaned" cells, respecting quoted fields.
 *
 * @param {string} csvFilename The CSV filename to fetch (relative path)
 * @returns {Promise<string[][]>} The parsed CSV rows
 */
async function fetchCSV(csvFilename) {
  console.log(`Attempting to fetch CSV: ${csvFilename}`);

  try {
    const response = await fetch(csvFilename);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV file: ${response.status} ${response.statusText}`);
    }
    const csvText = await response.text();

    // Split text into lines, filtering out blank lines
    const lines = csvText
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log('Raw lines:', lines);

    // For each line, parse properly, then clean each cell
    const rows = lines.map(line => {
      const parsedCells = parseCsvLine(line);
      return parsedCells.map(cell => cleanCell(cell));
    });

    console.log('Parsed rows (with cleaned cells):', rows);
    return rows;
  } catch (error) {
    throw new Error('Error fetching CSV: ' + error.message);
  }
}

/**
 * Picks one row based on integer weight in the second cell of each row.
 *   row[0] = type
 *   row[1] = weight (integer >= 1)
 *   row[2..] = other data
 *
 * If totalWeight <= 0 (all invalid or zero), we fall back to uniform random.
 *
 * @param {string[][]} rows
 * @returns {string[]} The selected row
 */
function pickRowByWeight(rows) {
  const weightedRows = rows.map(r => {
    let w = parseInt(r[1], 10);
    // Default weight to 1 if it's invalid or < 1
    if (isNaN(w) || w < 1) {
      w = 1;
    }
    return { row: r, weight: w };
  });

  let totalWeight = 0;
  for (const wr of weightedRows) {
    totalWeight += wr.weight;
  }

  // If totalWeight is 0, fall back to uniform random
  if (totalWeight <= 0) {
    console.warn('Total weight is zero or invalid. Falling back to uniform random choice.');
    const randomIndex = Math.floor(getSecureRandomNumber() * rows.length);
    return rows[randomIndex];
  }

  // Generate a random number in [0, totalWeight)
  let rand = getSecureRandomNumber() * totalWeight;

  // Find which row corresponds to this random value
  for (const wr of weightedRows) {
    if (rand < wr.weight) {
      return wr.row;
    }
    rand -= wr.weight;
  }

  // Fallback (due to floating-point rounding, etc.)
  return weightedRows[weightedRows.length - 1].row;
}

/**
 * Stores redirect analytics (row type, final URL, timestamp) in localStorage.
 * @param {string} rowType The type of the row (e.g., 'link', 'git-specific', etc.)
 * @param {string} url The final URL the user is being redirected to
 */
function storeRedirectAnalytics(rowType, url) {
  try {
    let analyticsData = localStorage.getItem('redirectAnalytics');
    if (!analyticsData) {
      analyticsData = [];
    } else {
      analyticsData = JSON.parse(analyticsData);
    }

    analyticsData.push({
      rowType: rowType,
      url: url,
      timestamp: new Date().toISOString()
    });

    localStorage.setItem('redirectAnalytics', JSON.stringify(analyticsData));
  } catch (err) {
    // If localStorage is not available or any other error occurs, silently fail
    console.error('Failed to store redirect analytics:', err);
  }
}

/**
 * processRows is the original flow that picks a row and immediately redirects or fetches again.
 * We keep it intact because the user specifically asked us not to remove functionalities.
 * NOTE: We won't normally call it anymore if we have precomputed URLs in localStorage,
 * but we keep it for fallback or reference.
 *
 * @param {string[][]} rows Parsed CSV rows
 * @param {number} recursionDepth Avoid infinite recursion on nested CSV references
 */
async function processRows(rows, recursionDepth = 0) {
  // Basic safeguard against unexpected infinite loops
  if (recursionDepth > 20) {
    document.body.textContent = 'Error: Exceeded maximum CSV nesting depth.';
    return;
  }

  if (!rows.length) {
    document.body.textContent = 'CSV is empty or could not be parsed.';
    return;
  }

  // Weighted selection
  const selectedRow = pickRowByWeight(rows);

  console.log('All rows:', rows);
  console.log('Selected row:', selectedRow);

  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    // Format: link,<weight>,<url>
    const url = selectedRow[2];
    console.log('Redirecting to link:', url);

    // Store analytics
    storeRedirectAnalytics(rowType, url);

    window.location.href = url;
  }
  else if (rowType === 'git-specific') {
    // Format: git-specific,<weight>,username=xxxx,repository=yyyy,issueNumbers=1_2_3
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersStr = selectedRow[4].split('=')[1];
    const issueNumbersArr = issueNumbersStr.split('_');

    const randIdx = Math.floor(getSecureRandomNumber() * issueNumbersArr.length);
    const chosenIssue = issueNumbersArr[randIdx];
    const finalUrl = `https://github.com/${username}/${repository}/issues/${chosenIssue}`;

    console.log('Redirecting to git-specific issue:', finalUrl);

    // Store analytics
    storeRedirectAnalytics(rowType, finalUrl);

    window.location.href = finalUrl;
  }
  else if (rowType === 'git-range') {
    // Format: git-range,<weight>,username=xxxx,repository=yyyy,issueNumbers=min_max
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const rangeStr = selectedRow[4].split('=')[1];
    const [minStr, maxStr] = rangeStr.split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);

    if (isNaN(min) || isNaN(max)) {
      document.body.textContent = 'Invalid range in "git-range" row.';
      return;
    }

    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    const finalUrl = `https://github.com/${username}/${repository}/issues/${randomVal}`;

    console.log('Redirecting to git-range issue:', finalUrl);

    // Store analytics
    storeRedirectAnalytics(rowType, finalUrl);

    window.location.href = finalUrl;
  }
  else if (rowType === 'csv') {
    // Format: csv,<weight>,<another-file.csv>
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      document.body.textContent = 'CSV type found but no filename specified.';
      return;
    }
    console.log('Nested CSV found. Fetching:', nestedCsv);

    try {
      const nestedRows = await fetchCSV(nestedCsv);
      await processRows(nestedRows, recursionDepth + 1);
    } catch (error) {
      document.body.textContent = error.message;
    }
  }
  else {
    document.body.textContent = 'Unknown row type: ' + rowType;
  }
}

/**
 * This new function returns a Promise that resolves to the "final URL" we would redirect to,
 * **without** actually redirecting. It uses the same picking logic as processRows.
 *
 * We preserve the nested CSV calls, so that if a csv row is chosen, we do an additional fetch
 * and keep going recursively until we hit a final link or git-like URL.
 */
async function getFinalUrl(rows, recursionDepth = 0) {
  // Basic safeguard
  if (recursionDepth > 20) {
    throw new Error('Exceeded maximum CSV nesting depth.');
  }

  if (!rows.length) {
    throw new Error('CSV is empty or could not be parsed.');
  }

  const selectedRow = pickRowByWeight(rows);
  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    // Format: link,<weight>,<url>
    return selectedRow[2];
  }
  else if (rowType === 'git-specific') {
    // Format: git-specific,<weight>,username=xxxx,repository=yyyy,issueNumbers=1_2_3
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersStr = selectedRow[4].split('=')[1];
    const issueNumbersArr = issueNumbersStr.split('_');
    const randIdx = Math.floor(getSecureRandomNumber() * issueNumbersArr.length);
    const chosenIssue = issueNumbersArr[randIdx];
    return `https://github.com/${username}/${repository}/issues/${chosenIssue}`;
  }
  else if (rowType === 'git-range') {
    // Format: git-range,<weight>,username=xxxx,repository=yyyy,issueNumbers=min_max
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const rangeStr = selectedRow[4].split('=')[1];
    const [minStr, maxStr] = rangeStr.split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);

    if (isNaN(min) || isNaN(max)) {
      throw new Error('Invalid range in "git-range" row.');
    }

    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    return `https://github.com/${username}/${repository}/issues/${randomVal}`;
  }
  else if (rowType === 'csv') {
    // Nested CSV
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      throw new Error('CSV type found but no filename specified.');
    }
    const nestedRows = await fetchCSV(nestedCsv);
    return getFinalUrl(nestedRows, recursionDepth + 1);
  }
  else {
    throw new Error('Unknown row type: ' + rowType);
  }
}

/**
 * Fill up an array of 100 final URLs based on the existing randomization logic,
 * including nested CSV resolution. Show a progress bar while doing so.
 *
 * @param {string[][]} rows The top-level CSV data
 * @returns {Promise<string[]>} A promise resolving to an array of 100 final URLs
 */
async function generatePrecomputedUrls(rows) {
  const container = document.getElementById('progress-container');
  const bar = document.getElementById('progress-bar');
  container.style.display = 'block';

  const total = 100;
  const results = [];

  for (let i = 0; i < total; i++) {
    const url = await getFinalUrl(rows, 0);
    results.push(url);

    // Update progress bar
    const percent = Math.floor(((i + 1) / total) * 100);
    bar.style.width = percent + '%';
    bar.setAttribute('aria-valuenow', percent);
    bar.textContent = percent + '%';
  }

  // Hide progress after done
  container.style.display = 'none';
  return results;
}

/**
 * Check if our stored array is still valid (not older than 1 hour, and not empty).
 *
 * @returns {boolean} true if valid and not empty
 */
function isPrecomputedValidAndAvailable() {
  const precomputed = localStorage.getItem('precomputedUrls');
  const timestampStr = localStorage.getItem('precomputedTimestamp');

  if (!precomputed || !timestampStr) {
    return false;
  }

  try {
    const arr = JSON.parse(precomputed);
    if (!Array.isArray(arr) || arr.length === 0) {
      return false;
    }
    const storedTime = new Date(timestampStr).getTime();
    const now = Date.now();
    const diff = now - storedTime;
    // 1 hour = 3600000 ms
    if (diff > 3600000) {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}

/**
 * Pop one URL from our precomputed array in localStorage and store the updated array back.
 * Returns the popped URL or null if none.
 */
function popPrecomputedUrl() {
  const precomputed = JSON.parse(localStorage.getItem('precomputedUrls')) || [];
  if (precomputed.length === 0) {
    return null;
  }
  const url = precomputed.shift();
  localStorage.setItem('precomputedUrls', JSON.stringify(precomputed));
  return url;
}

/**
 * Save new array of 100 URLs and a timestamp in localStorage.
 */
function savePrecomputedUrls(urlArray) {
  localStorage.setItem('precomputedUrls', JSON.stringify(urlArray));
  localStorage.setItem('precomputedTimestamp', new Date().toISOString());
}

/**
 * This is the modified main entry point:
 * 1. Check if we have valid precomputed URLs in localStorage
 * 2. If yes, pop one and redirect
 * 3. If not valid or empty, fetch CSV, fix "null" weights, generate 100 final URLs, store them,
 *    pop one, redirect
 */
async function main() {
  const urlParams = new URLSearchParams(window.location.search);
  const target = urlParams.get('target');

  if (!target) {
    document.body.textContent = 'No "target" parameter found. Use ?target=filename.csv';
    return;
  }

  // If we already have a valid, non-empty set of precomputed URLs,
  // pop one and redirect.
  if (isPrecomputedValidAndAvailable()) {
    const url = popPrecomputedUrl();
    if (url) {
      // store analytics & redirect
      storeRedirectAnalytics('precomputed', url);
      window.location.href = url;
      return;
    }
  }

  // Otherwise, we need to fetch CSV and regenerate 100 results
  try {
    const rows = await fetchCSV(target);

    // Fix null weights
    const nonNullValues = rows
      .map(r => (r[1] !== 'null' ? parseInt(r[1], 10) : NaN))
      .filter(val => !isNaN(val));

    if (nonNullValues.length > 0) {
      const minVal = Math.min(...nonNullValues);
      const maxVal = Math.max(...nonNullValues);

      // Assign random values between minVal and maxVal (inclusive) where second column is "null"
      for (let i = 0; i < rows.length; i++) {
        if (rows[i][1] === 'null') {
          const randomVal = Math.floor(getSecureRandomNumber() * (maxVal - minVal + 1)) + minVal;
          rows[i][1] = String(randomVal);
        }
      }
    }

    // Now generate 100 final URLs
    const generated = await generatePrecomputedUrls(rows);
    savePrecomputedUrls(generated);

    // pop one and redirect
    const urlToUse = popPrecomputedUrl();
    if (!urlToUse) {
      throw new Error('Failed to generate a new URL.');
    }
    storeRedirectAnalytics('precomputed', urlToUse);
    window.location.href = urlToUse;
  } catch (error) {
    document.body.textContent = 'Failed to process CSV: ' + error.message;
  }
}

window.onload = main;
</script>

<!-- Minimal JS needed by Bootstrap 4 progress (Popper + jQuery) -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
