<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random CSV Redirect (Weighted + Nested CSV Support + Stripped Quotes)</title>
</head>
<body>
<script>
/**
 * Returns a cryptographically secure random number between 0 (inclusive) and 1 (exclusive).
 */
function getSecureRandomNumber() {
  const array = new Uint32Array(1);
  window.crypto.getRandomValues(array);
  return array[0] / (0xFFFFFFFF + 1);
}

/**
 * Strips leading/trailing quotes from a string. Also trims whitespace.
 * Example:  "\"https://www.youtube.com\"" => "https://www.youtube.com"
 */
function cleanCell(cell) {
  cell = cell.trim();
  // Remove leading/trailing quotes (single or double)
  cell = cell.replace(/^["']+|["']+$/g, '');
  return cell;
}

/**
 * Fetch and parse a CSV file, returning an array of rows.
 * Each row is an array of "cleaned" cells.
 *
 * @param {string} csvFilename The CSV filename to fetch (relative to this HTML file)
 * @returns {Promise<string[][]>} The parsed CSV rows
 */
async function fetchCSV(csvFilename) {
  console.log(`Attempting to fetch CSV: ${csvFilename}`);
  try {
    const response = await fetch(csvFilename);
    if (!response.ok) {
      throw new Error(`Failed to fetch CSV file: ${response.status} ${response.statusText}`);
    }
    const csvText = await response.text();

    // Split into lines, filtering out blank lines
    const lines = csvText
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);

    console.log('Raw lines:', lines);

    // Split each line by commas, then strip quotes from each cell
    const rows = lines.map(line => {
      const splitted = line.split(',');
      return splitted.map(cell => cleanCell(cell));
    });

    console.log('Parsed rows (with cleaned cells):', rows);
    return rows;
  } catch (error) {
    throw new Error('Error fetching CSV: ' + error.message);
  }
}

/**
 * Picks one row based on the integer weight in the second cell of each row.
 *   row[0] = type
 *   row[1] = weight (an integer >= 1 by assumption)
 *   row[2..] = other data
 *
 * If totalWeight <= 0 (e.g., all invalid or zero), we fall back to uniform random.
 *
 * @param {string[][]} rows
 * @returns {string[]} The selected row
 */
function pickRowByWeight(rows) {
  const weightedRows = rows.map(r => {
    // Attempt parse as integer; default to 1 if invalid or < 1
    let w = parseInt(r[1], 10);
    if (isNaN(w) || w < 1) {
      w = 1;
    }
    return { row: r, weight: w };
  });

  let totalWeight = 0;
  for (const wr of weightedRows) {
    totalWeight += wr.weight;
  }

  // If totalWeight is 0, fall back to uniform random
  if (totalWeight <= 0) {
    console.warn('Total weight is zero or invalid. Falling back to uniform random choice.');
    const randomIndex = Math.floor(getSecureRandomNumber() * rows.length);
    return rows[randomIndex];
  }

  // Generate a random number in [0, totalWeight)
  let rand = getSecureRandomNumber() * totalWeight;

  // Find which row corresponds to this random value
  for (const wr of weightedRows) {
    if (rand < wr.weight) {
      return wr.row;
    }
    rand -= wr.weight;
  }

  // Fallback (due to floating-point rounding, etc.)
  return weightedRows[weightedRows.length - 1].row;
}

/**
 * Processes the rows by picking one row (weighted) and then acting based on row type.
 *
 * @param {string[][]} rows Parsed CSV rows
 * @param {number} recursionDepth Tracks nested "csv" lookups to prevent infinite loops
 */
async function processRows(rows, recursionDepth = 0) {
  // Basic safeguard against unexpected infinite loops
  if (recursionDepth > 20) {
    document.body.textContent = 'Error: Exceeded maximum CSV nesting depth.';
    return;
  }

  if (!rows.length) {
    document.body.textContent = 'CSV is empty or could not be parsed.';
    return;
  }

  // Pick a row by weight
  const selectedRow = pickRowByWeight(rows);

  console.log('All rows:', rows);
  console.log('Selected row:', selectedRow);

  const rowType = selectedRow[0].trim();

  if (rowType === 'link') {
    // Format: link,<weight>,<url>
    const url = selectedRow[2];
    console.log('Redirecting to link:', url);
    window.location.href = url;
  }
  else if (rowType === 'git-specific') {
    // Format: git-specific,<weight>,username=xxxx,repository=yyyy,issueNumbers=1_2_3
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const issueNumbersStr = selectedRow[4].split('=')[1]; // e.g. "68_69_70"
    const issueNumbersArr = issueNumbersStr.split('_');

    const randIdx = Math.floor(getSecureRandomNumber() * issueNumbersArr.length);
    const chosenIssue = issueNumbersArr[randIdx];
    const finalUrl = `https://github.com/${username}/${repository}/issues/${chosenIssue}`;

    console.log('Redirecting to git-specific issue:', finalUrl);
    window.location.href = finalUrl;
  }
  else if (rowType === 'git-range') {
    // Format: git-range,<weight>,username=xxxx,repository=yyyy,issueNumbers=min_max
    const username = selectedRow[2].split('=')[1];
    const repository = selectedRow[3].split('=')[1];
    const rangeStr = selectedRow[4].split('=')[1]; // e.g. "1_3"
    const [minStr, maxStr] = rangeStr.split('_');
    const min = parseInt(minStr, 10);
    const max = parseInt(maxStr, 10);

    if (isNaN(min) || isNaN(max)) {
      document.body.textContent = 'Invalid range in "git-range" row.';
      return;
    }

    const randomVal = Math.floor(getSecureRandomNumber() * (max - min + 1)) + min;
    const finalUrl = `https://github.com/${username}/${repository}/issues/${randomVal}`;

    console.log('Redirecting to git-range issue:', finalUrl);
    window.location.href = finalUrl;
  }
  else if (rowType === 'csv') {
    // Format: csv,<weight>,<filename>
    const nestedCsv = selectedRow[2];
    if (!nestedCsv) {
      document.body.textContent = 'CSV type found but no filename specified.';
      return;
    }
    console.log('Nested CSV found. Fetching:', nestedCsv);

    try {
      const nestedRows = await fetchCSV(nestedCsv);
      await processRows(nestedRows, recursionDepth + 1);
    } catch (error) {
      document.body.textContent = error.message;
    }
  }
  else {
    document.body.textContent = 'Unknown row type: ' + rowType;
  }
}

/**
 * Main entry point:
 * 1. Read the "target" param from URL (e.g. ?target=filename.csv)
 * 2. Fetch/parse the CSV
 * 3. Process rows
 */
async function main() {
  const urlParams = new URLSearchParams(window.location.search);
  const target = urlParams.get('target');

  if (!target) {
    document.body.textContent = 'No "target" parameter found. Use ?target=filename.csv';
    return;
  }

  try {
    const rows = await fetchCSV(target);
    await processRows(rows, 0);
  } catch (error) {
    document.body.textContent = 'Failed to process CSV: ' + error.message;
  }
}

window.onload = main;
</script>
</body>
</html>
